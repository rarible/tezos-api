/**
 * TzKT API
 *
 * # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Granadanet: `https://api.granadanet.tzkt.io/` ([view docs](https://api.granadanet.tzkt.io))     - Hangzhou2net: `https://api.hangzhou2net.tzkt.io/` ([view docs](https://api.hangzhou2net.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@baking-bad.org  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you should mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  --- 
 *
 * The version of the OpenAPI document: v1.7.0
 * Contact: hello@baking-bad.org
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.rarible.tzkt.api

import java.io.IOException

import com.rarible.tzkt.model.parameters.AccountParameter
import com.rarible.tzkt.model.parameters.JsonParameter
import com.rarible.tzkt.model.parameters.NatParameter
import com.rarible.tzkt.model.parameters.OffsetParameter
import com.rarible.tzkt.model.parameters.SelectionParameter
import com.rarible.tzkt.model.parameters.SortParameter
import com.rarible.tzkt.model.parameters.TimestampParameter
import com.rarible.tzkt.model.parameters.TokenStandardParameter
import com.rarible.tzkt.models.Token
import com.rarible.tzkt.models.TokenBalance
import com.rarible.tzkt.models.TokenBalanceShort
import com.rarible.tzkt.models.TokenTransfer

import com.rarible.tzkt.infrastructure.ApiClient
import com.rarible.tzkt.infrastructure.ApiResponse
import com.rarible.tzkt.infrastructure.ClientException
import com.rarible.tzkt.infrastructure.ClientError
import com.rarible.tzkt.infrastructure.ServerException
import com.rarible.tzkt.infrastructure.ServerError
import com.rarible.tzkt.infrastructure.MultiValueMap
import com.rarible.tzkt.infrastructure.RequestConfig
import com.rarible.tzkt.infrastructure.RequestMethod
import com.rarible.tzkt.infrastructure.ResponseType
import com.rarible.tzkt.infrastructure.Success
import com.rarible.tzkt.model.parameters.IntParameter
import okhttp3.internal.platform.android.AndroidLogHandler.getFilter

class TokensApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.tzkt.io")
        }
    }

    /**
    * Get token balances
    * Returns a list of token balances.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the balance was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the balance was last changed.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return kotlin.collections.List<TokenBalance>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokensGetTokenBalances(id: IntParameter?, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : kotlin.collections.List<TokenBalance> {
        val localVarResponse = tokensGetTokenBalancesWithHttpInfo(id = id, account = account, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, balance = balance, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime, sort = sort, offset = offset, limit = limit, select = select)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TokenBalance>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get token balances
    * Returns a list of token balances.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the balance was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the balance was last changed.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return ApiResponse<kotlin.collections.List<TokenBalance>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokensGetTokenBalancesWithHttpInfo(id: IntParameter?, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : ApiResponse<kotlin.collections.List<TokenBalance>?> {
        val localVariableConfig = tokensGetTokenBalancesRequestConfig(id = id, account = account, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, balance = balance, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime, sort = sort, offset = offset, limit = limit, select = select)

        return request(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tokensGetTokenBalances
    *
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the balance was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the balance was last changed.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return RequestConfig
    */
    private fun tokensGetTokenBalancesRequestConfig(id: IntParameter?, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id${id.getFilter()}", listOf(id.getFilterValue()))
                }
                if (account != null) {
                    put("account${account.getFilter()}", listOf(account.getFilterValue()))
                }
                if (tokenId != null) {
                    put("token.id${tokenId.getFilter()}", listOf(tokenId.getFilterValue()))
                }
                if (tokenContract != null) {
                    put("token.contract${tokenContract.getFilter()}", listOf(tokenContract.getFilterValue()))
                }
                if (tokenTokenId != null) {
                    put("token.tokenId${tokenTokenId.getFilter()}", listOf(tokenTokenId.getFilterValue()))
                }
                if (tokenStandard != null) {
                    put("token.standard${tokenStandard.getFilter()}", listOf(tokenStandard.getFilterValue()))
                }
                if (tokenMetadata != null) {
                    put("token.metadata${tokenMetadata.getFilter()}", listOf(tokenMetadata.getFilterValue()))
                }
                if (tokenHasFilters != null) {
                    put("token.HasFilters", listOf(tokenHasFilters.toString()))
                }
                if (balance != null) {
                    put("balance${balance.getFilter()}", listOf(balance.getFilterValue()))
                }
                if (firstLevel != null) {
                    put("firstLevel${firstLevel.getFilter()}", listOf(firstLevel.getFilterValue()))
                }
                if (firstTime != null) {
                    put("firstTime${firstTime.getFilter()}", listOf(firstTime.getFilterValue()))
                }
                if (lastLevel != null) {
                    put("lastLevel${lastLevel.getFilter()}", listOf(lastLevel.getFilterValue()))
                }
                if (lastTime != null) {
                    put("lastTime${lastTime.getFilter()}", listOf(lastTime.getFilterValue()))
                }
                if (sort != null) {
                    put("sort${sort.getFilter()}", listOf(sort.getFilterValue()))
                }
                if (offset != null) {
                    put("offset${offset.getFilter()}", listOf(offset.getFilterValue()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (select != null) {
                    put("select${select.getFilter()}", listOf(select.getFilterValue()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens/balances",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get historical token balances
    * Returns a list of token balances at the end of the specified block. Note, this endpoint is quite heavy, therefore at least one of the filters (&#x60;account&#x60;, &#x60;token.id&#x60;, &#x60;token.contract&#x60; with &#x60;token.tokenId&#x60;) must be specified.
    * @param level Level of the block at the end of which historical balances must be calculated 
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return kotlin.collections.List<TokenBalanceShort>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokensGetTokenBalances2(level: kotlin.Int, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : kotlin.collections.List<TokenBalanceShort> {
        val localVarResponse = tokensGetTokenBalances2WithHttpInfo(level = level, account = account, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, balance = balance, sort = sort, offset = offset, limit = limit, select = select)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TokenBalanceShort>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get historical token balances
    * Returns a list of token balances at the end of the specified block. Note, this endpoint is quite heavy, therefore at least one of the filters (&#x60;account&#x60;, &#x60;token.id&#x60;, &#x60;token.contract&#x60; with &#x60;token.tokenId&#x60;) must be specified.
    * @param level Level of the block at the end of which historical balances must be calculated 
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return ApiResponse<kotlin.collections.List<TokenBalanceShort>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokensGetTokenBalances2WithHttpInfo(level: kotlin.Int, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : ApiResponse<kotlin.collections.List<TokenBalanceShort>?> {
        val localVariableConfig = tokensGetTokenBalances2RequestConfig(level = level, account = account, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, balance = balance, sort = sort, offset = offset, limit = limit, select = select)

        return request<Unit, kotlin.collections.List<TokenBalanceShort>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tokensGetTokenBalances2
    *
    * @param level Level of the block at the end of which historical balances must be calculated 
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return RequestConfig
    */
    fun tokensGetTokenBalances2RequestConfig(level: kotlin.Int, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (account != null) {
                    put("account${account.getFilter()}", listOf(account.getFilterValue()))
                }
                if (tokenId != null) {
                    put("token.id${tokenId.getFilter()}", listOf(tokenId.getFilterValue()))
                }
                if (tokenContract != null) {
                    put("token.contract${tokenContract.getFilter()}", listOf(tokenContract.getFilterValue()))
                }
                if (tokenTokenId != null) {
                    put("token.tokenId${tokenTokenId.getFilter()}", listOf(tokenTokenId.getFilterValue()))
                }
                if (tokenStandard != null) {
                    put("token.standard${tokenStandard.getFilter()}", listOf(tokenStandard.getFilterValue()))
                }
                if (tokenMetadata != null) {
                    put("token.metadata${tokenMetadata.getFilter()}", listOf(tokenMetadata.getFilterValue()))
                }
                if (tokenHasFilters != null) {
                    put("token.HasFilters", listOf(tokenHasFilters.toString()))
                }
                if (balance != null) {
                    put("balance${balance.getFilter()}", listOf(balance.getFilterValue()))
                }
                if (sort != null) {
                    put("sort${sort.getFilter()}", listOf(sort.getFilterValue()))
                }
                if (offset != null) {
                    put("offset${offset.getFilter()}", listOf(offset.getFilterValue()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (select != null) {
                    put("select${select.getFilter()}", listOf(select.getFilterValue()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens/historical_balances/{level}".replace("{"+"level"+"}", "$level"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get token balances count
    * Returns a total number of token balances.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the balance was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the balance was last changed.   Click on the parameter to expand more details. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokensGetTokenBalancesCount(id: IntParameter?, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?) : kotlin.Int {
        val localVarResponse = tokensGetTokenBalancesCountWithHttpInfo(id = id, account = account, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, balance = balance, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get token balances count
    * Returns a total number of token balances.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the balance was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the balance was last changed.   Click on the parameter to expand more details. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokensGetTokenBalancesCountWithHttpInfo(id: IntParameter?, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = tokensGetTokenBalancesCountRequestConfig(id = id, account = account, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, balance = balance, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tokensGetTokenBalancesCount
    *
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param account Filter by account address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param balance Filter by balance.   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the balance was first changed.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the balance was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the balance was last changed.   Click on the parameter to expand more details. (optional)
    * @return RequestConfig
    */
    fun tokensGetTokenBalancesCountRequestConfig(id: IntParameter?, account: AccountParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, balance: NatParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (account != null) {
                     put("account${account.getFilter()}", listOf(account.getFilterValue()))
                }
                if (tokenId != null) {
                    put("token.id${tokenId.getFilter()}", listOf(tokenId.getFilterValue()))
                }
                if (tokenContract != null) {
                    put("token.contract${tokenContract.getFilter()}", listOf(tokenContract.getFilterValue()))
                }
                if (tokenTokenId != null) {
                    put("token.tokenId${tokenTokenId.getFilter()}", listOf(tokenTokenId.getFilterValue()))
                }
                if (tokenStandard != null) {
                    put("token.standard${tokenStandard.getFilter()}", listOf(tokenStandard.getFilterValue()))
                }
                if (tokenMetadata != null) {
                    put("token.metadata${tokenMetadata.getFilter()}", listOf(tokenMetadata.getFilterValue()))
                }
                if (tokenHasFilters != null) {
                    put("token.HasFilters", listOf(tokenHasFilters.toString()))
                }
                if (balance != null) {
                    put("balance${balance.getFilter()}", listOf(balance.getFilterValue()))
                }
                if (firstLevel != null) {
                    put("firstLevel${firstLevel.getFilter()}", listOf(firstLevel.getFilterValue()))
                }
                if (firstTime != null) {
                    put("firstTime${firstTime.getFilter()}", listOf(firstTime.getFilterValue()))
                }
                if (lastLevel != null) {
                    put("lastLevel${lastLevel.getFilter()}", listOf(lastLevel.getFilterValue()))
                }
                if (lastTime != null) {
                    put("lastTime${lastTime.getFilter()}", listOf(lastTime.getFilterValue()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens/balances/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get token transfers
    * Returns a list of token transfers.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param level Filter by level of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param timestamp Filter by timestamp (ISO 8601) of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param anyof Filter by any of the specified fields (&#x60;from&#x60; or &#x60;to&#x60;). Example: &#x60;anyof.from.to&#x3D;tz1...&#x60; will return transfers where &#x60;from&#x60; OR &#x60;to&#x60; is equal to the specified value. This parameter is useful when you need to get both incoming and outgoing transfers of the account at once.   Click on the parameter to expand more details. (optional)
    * @param from Filter by sender account address.   Click on the parameter to expand more details. (optional)
    * @param to Filter by target account address.   Click on the parameter to expand more details. (optional)
    * @param amount Filter by amount.   Click on the parameter to expand more details. (optional)
    * @param transactionId Filter by id of the transaction, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param originationId Filter by id of the origination, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param migrationId Filter by id of the migration, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return kotlin.collections.List<TokenTransfer>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokensGetTokenTransfers(id: IntParameter?, level: IntParameter?, timestamp: TimestampParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, anyof: kotlin.String?, from: AccountParameter?, to: AccountParameter?, amount: NatParameter?, transactionId: IntParameter?, originationId: IntParameter?, migrationId: IntParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : kotlin.collections.List<TokenTransfer> {
        val localVarResponse = tokensGetTokenTransfersWithHttpInfo(id = id, level = level, timestamp = timestamp, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, anyof = anyof, from = from, to = to, amount = amount, transactionId = transactionId, originationId = originationId, migrationId = migrationId, sort = sort, offset = offset, limit = limit, select = select)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TokenTransfer>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get token transfers
    * Returns a list of token transfers.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param level Filter by level of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param timestamp Filter by timestamp (ISO 8601) of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param anyof Filter by any of the specified fields (&#x60;from&#x60; or &#x60;to&#x60;). Example: &#x60;anyof.from.to&#x3D;tz1...&#x60; will return transfers where &#x60;from&#x60; OR &#x60;to&#x60; is equal to the specified value. This parameter is useful when you need to get both incoming and outgoing transfers of the account at once.   Click on the parameter to expand more details. (optional)
    * @param from Filter by sender account address.   Click on the parameter to expand more details. (optional)
    * @param to Filter by target account address.   Click on the parameter to expand more details. (optional)
    * @param amount Filter by amount.   Click on the parameter to expand more details. (optional)
    * @param transactionId Filter by id of the transaction, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param originationId Filter by id of the origination, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param migrationId Filter by id of the migration, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return ApiResponse<kotlin.collections.List<TokenTransfer>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokensGetTokenTransfersWithHttpInfo(id: IntParameter?, level: IntParameter?, timestamp: TimestampParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, anyof: kotlin.String?, from: AccountParameter?, to: AccountParameter?, amount: NatParameter?, transactionId: IntParameter?, originationId: IntParameter?, migrationId: IntParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : ApiResponse<kotlin.collections.List<TokenTransfer>?> {
        val localVariableConfig = tokensGetTokenTransfersRequestConfig(id = id, level = level, timestamp = timestamp, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, anyof = anyof, from = from, to = to, amount = amount, transactionId = transactionId, originationId = originationId, migrationId = migrationId, sort = sort, offset = offset, limit = limit, select = select)

        return request<Unit, kotlin.collections.List<TokenTransfer>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tokensGetTokenTransfers
    *
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param level Filter by level of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param timestamp Filter by timestamp (ISO 8601) of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param anyof Filter by any of the specified fields (&#x60;from&#x60; or &#x60;to&#x60;). Example: &#x60;anyof.from.to&#x3D;tz1...&#x60; will return transfers where &#x60;from&#x60; OR &#x60;to&#x60; is equal to the specified value. This parameter is useful when you need to get both incoming and outgoing transfers of the account at once.   Click on the parameter to expand more details. (optional)
    * @param from Filter by sender account address.   Click on the parameter to expand more details. (optional)
    * @param to Filter by target account address.   Click on the parameter to expand more details. (optional)
    * @param amount Filter by amount.   Click on the parameter to expand more details. (optional)
    * @param transactionId Filter by id of the transaction, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param originationId Filter by id of the origination, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param migrationId Filter by id of the migration, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return RequestConfig
    */
    fun tokensGetTokenTransfersRequestConfig(id: IntParameter?, level: IntParameter?, timestamp: TimestampParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, anyof: kotlin.String?, from: AccountParameter?, to: AccountParameter?, amount: NatParameter?, transactionId: IntParameter?, originationId: IntParameter?, migrationId: IntParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (tokenId != null) {
                    put("token.id${tokenId.getFilter()}", listOf(tokenId.getFilterValue()))
                }
                if (tokenContract != null) {
                    put("token.contract", listOf(tokenContract.toString()))
                }
                if (tokenTokenId != null) {
                    put("token.tokenId${tokenTokenId.getFilter()}", listOf(tokenTokenId.getFilterValue()))
                }
                if (tokenStandard != null) {
                    put("token.standard${tokenStandard.getFilter()}", listOf(tokenStandard.getFilterValue()))
                }
                if (tokenMetadata != null) {
                    put("token.metadata", listOf(tokenMetadata.toString()))
                }
                if (tokenHasFilters != null) {
                    put("token.HasFilters", listOf(tokenHasFilters.toString()))
                }
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
                if (amount != null) {
                    put("amount", listOf(amount.toString()))
                }
                if (transactionId != null) {
                    put("transactionId", listOf(transactionId.toString()))
                }
                if (originationId != null) {
                    put("originationId", listOf(originationId.toString()))
                }
                if (migrationId != null) {
                    put("migrationId", listOf(migrationId.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens/transfers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get token transfers count
    * Returns the total number of token transfers.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param level Filter by level of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param timestamp Filter by timestamp (ISO 8601) of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param anyof Filter by any of the specified fields (&#x60;from&#x60; or &#x60;to&#x60;). Example: &#x60;anyof.from.to&#x3D;tz1...&#x60; will return transfers where &#x60;from&#x60; OR &#x60;to&#x60; is equal to the specified value. This parameter is useful when you need to get both incoming and outgoing transfers of the account at once.   Click on the parameter to expand more details. (optional)
    * @param from Filter by sender account address.   Click on the parameter to expand more details. (optional)
    * @param to Filter by target account address.   Click on the parameter to expand more details. (optional)
    * @param amount Filter by amount.   Click on the parameter to expand more details. (optional)
    * @param transactionId Filter by id of the transaction, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param originationId Filter by id of the origination, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param migrationId Filter by id of the migration, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokensGetTokenTransfersCount(id: IntParameter?, level: IntParameter?, timestamp: TimestampParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, anyof: kotlin.String?, from: AccountParameter?, to: AccountParameter?, amount: NatParameter?, transactionId: IntParameter?, originationId: IntParameter?, migrationId: IntParameter?) : kotlin.Int {
        val localVarResponse = tokensGetTokenTransfersCountWithHttpInfo(id = id, level = level, timestamp = timestamp, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, anyof = anyof, from = from, to = to, amount = amount, transactionId = transactionId, originationId = originationId, migrationId = migrationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get token transfers count
    * Returns the total number of token transfers.
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param level Filter by level of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param timestamp Filter by timestamp (ISO 8601) of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param anyof Filter by any of the specified fields (&#x60;from&#x60; or &#x60;to&#x60;). Example: &#x60;anyof.from.to&#x3D;tz1...&#x60; will return transfers where &#x60;from&#x60; OR &#x60;to&#x60; is equal to the specified value. This parameter is useful when you need to get both incoming and outgoing transfers of the account at once.   Click on the parameter to expand more details. (optional)
    * @param from Filter by sender account address.   Click on the parameter to expand more details. (optional)
    * @param to Filter by target account address.   Click on the parameter to expand more details. (optional)
    * @param amount Filter by amount.   Click on the parameter to expand more details. (optional)
    * @param transactionId Filter by id of the transaction, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param originationId Filter by id of the origination, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param migrationId Filter by id of the migration, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokensGetTokenTransfersCountWithHttpInfo(id: IntParameter?, level: IntParameter?, timestamp: TimestampParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, anyof: kotlin.String?, from: AccountParameter?, to: AccountParameter?, amount: NatParameter?, transactionId: IntParameter?, originationId: IntParameter?, migrationId: IntParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = tokensGetTokenTransfersCountRequestConfig(id = id, level = level, timestamp = timestamp, tokenId = tokenId, tokenContract = tokenContract, tokenTokenId = tokenTokenId, tokenStandard = tokenStandard, tokenMetadata = tokenMetadata, tokenHasFilters = tokenHasFilters, anyof = anyof, from = from, to = to, amount = amount, transactionId = transactionId, originationId = originationId, migrationId = migrationId)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tokensGetTokenTransfersCount
    *
    * @param id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
    * @param level Filter by level of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param timestamp Filter by timestamp (ISO 8601) of the block where the transfer was made.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenContract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenTokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenStandard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param tokenMetadata Filter by metadata. Note, this parameter supports the following format: &#x60;token.metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by, for example: &#x60;?token.metadata.symbol.in&#x3D;kUSD,uUSD&#x60;.   Click on the parameter to expand more details. (optional)
    * @param tokenHasFilters  (optional)
    * @param anyof Filter by any of the specified fields (&#x60;from&#x60; or &#x60;to&#x60;). Example: &#x60;anyof.from.to&#x3D;tz1...&#x60; will return transfers where &#x60;from&#x60; OR &#x60;to&#x60; is equal to the specified value. This parameter is useful when you need to get both incoming and outgoing transfers of the account at once.   Click on the parameter to expand more details. (optional)
    * @param from Filter by sender account address.   Click on the parameter to expand more details. (optional)
    * @param to Filter by target account address.   Click on the parameter to expand more details. (optional)
    * @param amount Filter by amount.   Click on the parameter to expand more details. (optional)
    * @param transactionId Filter by id of the transaction, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param originationId Filter by id of the origination, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @param migrationId Filter by id of the migration, caused the token transfer.   Click on the parameter to expand more details. (optional)
    * @return RequestConfig
    */
    fun tokensGetTokenTransfersCountRequestConfig(id: IntParameter?, level: IntParameter?, timestamp: TimestampParameter?, tokenId: IntParameter?, tokenContract: AccountParameter?, tokenTokenId: NatParameter?, tokenStandard: TokenStandardParameter?, tokenMetadata: JsonParameter?, tokenHasFilters: kotlin.Boolean?, anyof: kotlin.String?, from: AccountParameter?, to: AccountParameter?, amount: NatParameter?, transactionId: IntParameter?, originationId: IntParameter?, migrationId: IntParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id${id.getFilter()}", listOf(id.getFilterValue()))
                }
                if (level != null) {
                    put("level${level.getFilter()}", listOf(level.getFilterValue()))
                }
                if (timestamp != null) {
                    put("timestamp${timestamp.getFilter()}", listOf(timestamp.getFilterValue()))
                }
                if (tokenId != null) {
                    put("token.id${tokenId.getFilter()}", listOf(tokenId.getFilterValue()))
                }
                if (tokenContract != null) {
                    put("token.contract${tokenContract.getFilter()}", listOf(tokenContract.getFilterValue()))
                }
                if (tokenTokenId != null) {
                    put("token.tokenId${tokenTokenId.getFilter()}", listOf(tokenTokenId.getFilterValue()))
                }
                if (tokenStandard != null) {
                    put("token.standard${tokenStandard.getFilter()}", listOf(tokenStandard.getFilterValue()))
                }
                if (tokenMetadata != null) {
                    put("token.metadata${tokenMetadata.getFilter()}", listOf(tokenMetadata.getFilterValue()))
                }
                if (tokenHasFilters != null) {
                    put("token.HasFilters", listOf(tokenHasFilters.toString()))
                }
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (from != null) {
                    put("from${from.getFilter()}", listOf(from.getFilterValue()))
                }
                if (to != null) {
                    put("to${to.getFilter()}", listOf(to.getFilterValue()))
                }
                if (amount != null) {
                    put("amount${amount.getFilter()}", listOf(amount.getFilterValue()))
                }
                if (transactionId != null) {
                    put("transactionId${transactionId.getFilter()}", listOf(transactionId.getFilterValue()))
                }
                if (originationId != null) {
                    put("originationId${originationId.getFilter()}", listOf(originationId.getFilterValue()))
                }
                if (migrationId != null) {
                    put("migrationId${migrationId.getFilter()}", listOf(migrationId.getFilterValue()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens/transfers/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get tokens
    * Returns a list of tokens.
    * @param id Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60; nat value.   Click on the parameter to expand more details. (optional)
    * @param contract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param standard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param metadata Filter by metadata.   Note, this parameter supports the following format: &#x60;metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by (for example, &#x60;?metadata.symbol.in&#x3D;kUSD,uUSD&#x60;).   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return kotlin.collections.List<Token>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokensGetTokens(id: IntParameter?, contract: AccountParameter?, tokenId: NatParameter?, standard: TokenStandardParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, metadata: JsonParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : kotlin.collections.List<Token> {
        val localVarResponse = tokensGetTokensWithHttpInfo(id = id, contract = contract, tokenId = tokenId, standard = standard, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime, metadata = metadata, sort = sort, offset = offset, limit = limit, select = select)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Token>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get tokens
    * Returns a list of tokens.
    * @param id Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60; nat value.   Click on the parameter to expand more details. (optional)
    * @param contract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param standard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param metadata Filter by metadata.   Note, this parameter supports the following format: &#x60;metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by (for example, &#x60;?metadata.symbol.in&#x3D;kUSD,uUSD&#x60;).   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return ApiResponse<kotlin.collections.List<Token>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokensGetTokensWithHttpInfo(id: IntParameter?, contract: AccountParameter?, tokenId: NatParameter?, standard: TokenStandardParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, metadata: JsonParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : ApiResponse<kotlin.collections.List<Token>?> {
        val localVariableConfig = tokensGetTokensRequestConfig(id = id, contract = contract, tokenId = tokenId, standard = standard, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime, metadata = metadata, sort = sort, offset = offset, limit = limit, select = select)

        return request<Unit, kotlin.collections.List<Token>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tokensGetTokens
    *
    * @param id Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60; nat value.   Click on the parameter to expand more details. (optional)
    * @param contract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param standard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param metadata Filter by metadata.   Note, this parameter supports the following format: &#x60;metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by (for example, &#x60;?metadata.symbol.in&#x3D;kUSD,uUSD&#x60;).   Click on the parameter to expand more details. (optional)
    * @param sort Sorts items (asc or desc) by the specified field. You can see what fileds can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
    * @param offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
    * @param limit Maximum number of items to return. (optional)
    * @param select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
    * @return RequestConfig
    */
    fun tokensGetTokensRequestConfig(id: IntParameter?, contract: AccountParameter?, tokenId: NatParameter?, standard: TokenStandardParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, metadata: JsonParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, select: SelectionParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id${id.getFilter()}", listOf(id.getFilterValue()))
                }
                if (contract != null) {
                    put("contract${contract.getFilter()}", listOf(contract.getFilterValue()))
                }
                if (tokenId != null) {
                    put("tokenId${tokenId.getFilter()}", listOf(tokenId.getFilterValue()))
                }
                if (standard != null) {
                    put("standard${standard.getFilter()}", listOf(standard.getFilterValue()))
                }
                if (firstLevel != null) {
                    put("firstLevel${firstLevel.getFilter()}", listOf(firstLevel.getFilterValue()))
                }
                if (firstTime != null) {
                    put("firstTime${firstTime.getFilter()}", listOf(firstTime.getFilterValue()))
                }
                if (lastLevel != null) {
                    put("lastLevel${lastLevel.getFilter()}", listOf(lastLevel.getFilterValue()))
                }
                if (lastTime != null) {
                    put("lastTime${lastTime.getFilter()}", listOf(lastTime.getFilterValue()))
                }
                if (metadata != null) {
                    put("metadata${metadata.getFilter()}", listOf(metadata.getFilterValue()))
                }
                if (sort != null) {
                    put("sort${sort.getFilter()}", listOf(sort.getFilterValue()))
                }
                if (offset != null) {
                    put("offset${offset.getFilter()}", listOf(offset.getFilterValue()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (select != null) {
                    put("select${select.getFilter()}", listOf(select.getFilterValue()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get tokens count
    * Returns a total number of tokens.
    * @param id Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60; nat value.   Click on the parameter to expand more details. (optional)
    * @param contract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param standard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param metadata Filter by metadata.   Note, this parameter supports the following format: &#x60;metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by (for example, &#x60;?metadata.symbol.in&#x3D;kUSD,uUSD&#x60;).   Click on the parameter to expand more details. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokensGetTokensCount(id: IntParameter?, contract: AccountParameter?, tokenId: NatParameter?, standard: TokenStandardParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, metadata: JsonParameter?) : kotlin.Int {
        val localVarResponse = tokensGetTokensCountWithHttpInfo(id = id, contract = contract, tokenId = tokenId, standard = standard, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime, metadata = metadata)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get tokens count
    * Returns a total number of tokens.
    * @param id Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60; nat value.   Click on the parameter to expand more details. (optional)
    * @param contract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param standard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param metadata Filter by metadata.   Note, this parameter supports the following format: &#x60;metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by (for example, &#x60;?metadata.symbol.in&#x3D;kUSD,uUSD&#x60;).   Click on the parameter to expand more details. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tokensGetTokensCountWithHttpInfo(id: IntParameter?, contract: AccountParameter?, tokenId: NatParameter?, standard: TokenStandardParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, metadata: JsonParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = tokensGetTokensCountRequestConfig(id = id, contract = contract, tokenId = tokenId, standard = standard, firstLevel = firstLevel, firstTime = firstTime, lastLevel = lastLevel, lastTime = lastTime, metadata = metadata)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tokensGetTokensCount
    *
    * @param id Filter by internal TzKT id. Note, this is not the same as &#x60;tokenId&#x60; nat value.   Click on the parameter to expand more details. (optional)
    * @param contract Filter by contract address.   Click on the parameter to expand more details. (optional)
    * @param tokenId Filter by tokenId (for FA1.2 tokens tokenId is always &#x60;\&quot;0\&quot;&#x60;).   Click on the parameter to expand more details. (optional)
    * @param standard Filter by token standard (&#x60;fa1.2&#x60; or &#x60;fa2&#x60;).   Click on the parameter to expand more details. (optional)
    * @param firstLevel Filter by level of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param firstTime Filter by timestamp (ISO 8601) of the block where the token was first seen.   Click on the parameter to expand more details. (optional)
    * @param lastLevel Filter by level of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param lastTime Filter by timestamp (ISO 8601) of the block where the token was last seen.   Click on the parameter to expand more details. (optional)
    * @param metadata Filter by metadata.   Note, this parameter supports the following format: &#x60;metadata{.path?}{.mode?}&#x3D;...&#x60;, so you can specify a path to a particular field to filter by (for example, &#x60;?metadata.symbol.in&#x3D;kUSD,uUSD&#x60;).   Click on the parameter to expand more details. (optional)
    * @return RequestConfig
    */
    fun tokensGetTokensCountRequestConfig(id: IntParameter?, contract: AccountParameter?, tokenId: NatParameter?, standard: TokenStandardParameter?, firstLevel: IntParameter?, firstTime: TimestampParameter?, lastLevel: IntParameter?, lastTime: TimestampParameter?, metadata: JsonParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id${id.getFilter()}", listOf(id.getFilterValue()))
                }
                if (contract != null) {
                    put("contract${contract.getFilter()}", listOf(contract.getFilterValue()))
                }
                if (tokenId != null) {
                    put("tokenId${tokenId.getFilter()}", listOf(tokenId.getFilterValue()))
                }
                if (standard != null) {
                    put("standard${standard.getFilter()}", listOf(standard.getFilterValue()))
                }
                if (firstLevel != null) {
                    put("firstLevel${firstLevel.getFilter()}", listOf(firstLevel.getFilterValue()))
                }
                if (firstTime != null) {
                    put("firstTime${firstTime.getFilter()}", listOf(firstTime.getFilterValue()))
                }
                if (lastLevel != null) {
                    put("lastLevel${lastLevel.getFilter()}", listOf(lastLevel.getFilterValue()))
                }
                if (lastTime != null) {
                    put("lastTime${lastTime.getFilter()}", listOf(lastTime.getFilterValue()))
                }
                if (metadata != null) {
                    put("metadata${metadata.getFilter()}", listOf(metadata.getFilterValue()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/tokens/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
