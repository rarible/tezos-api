/**
 * TzKT API
 *
 * # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Granadanet: `https://api.granadanet.tzkt.io/` ([view docs](https://api.granadanet.tzkt.io))     - Hangzhou2net: `https://api.hangzhou2net.tzkt.io/` ([view docs](https://api.hangzhou2net.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@baking-bad.org  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you should mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  --- 
 *
 * The version of the OpenAPI document: v1.7.0
 * Contact: hello@baking-bad.org
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.rarible.tzkt.api

import java.io.IOException

import com.rarible.tzkt.models.BigMap
import com.rarible.tzkt.models.BigMapKey
import com.rarible.tzkt.models.BigMapKeyHistorical
import com.rarible.tzkt.models.BigMapKeyUpdate
import com.rarible.tzkt.models.Contract
import com.rarible.tzkt.models.ContractInterface
import com.rarible.tzkt.models.ContractView
import com.rarible.tzkt.models.Entrypoint
import com.rarible.tzkt.models.IMicheline
import com.rarible.tzkt.model.parameters.AccountParameter
import com.rarible.tzkt.model.parameters.BigMapTagsParameter
import com.rarible.tzkt.model.parameters.ContractKindParameter
import com.rarible.tzkt.model.parameters.IntParameter
import com.rarible.tzkt.model.parameters.JsonParameter
import com.rarible.tzkt.models.MichelineFormat
import com.rarible.tzkt.model.parameters.OffsetParameter
import com.rarible.tzkt.model.parameters.SelectParameter
import com.rarible.tzkt.model.parameters.SortParameter
import com.rarible.tzkt.models.StorageRecord

import com.rarible.tzkt.infrastructure.ApiClient
import com.rarible.tzkt.infrastructure.ApiResponse
import com.rarible.tzkt.infrastructure.ClientException
import com.rarible.tzkt.infrastructure.ClientError
import com.rarible.tzkt.infrastructure.ServerException
import com.rarible.tzkt.infrastructure.ServerError
import com.rarible.tzkt.infrastructure.MultiValueMap
import com.rarible.tzkt.infrastructure.RequestConfig
import com.rarible.tzkt.infrastructure.RequestMethod
import com.rarible.tzkt.infrastructure.ResponseType
import com.rarible.tzkt.infrastructure.Success

class ContractsApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.tzkt.io")
        }
    }

    /**
    * Build entrypoint parameters
    * Returns micheline parameters converted from its JSON representation.
    * @param address Contract address 
    * @param name Entrypoint name 
    * @param `value` Json parameters (optional)
    * @return java.io.File
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsBuildEntrypointParametersGET(address: kotlin.String, name: kotlin.String, `value`: kotlin.String?) : java.io.File {
        val localVarResponse = contractsBuildEntrypointParametersGETWithHttpInfo(address = address, name = name, `value` = `value`)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Build entrypoint parameters
    * Returns micheline parameters converted from its JSON representation.
    * @param address Contract address 
    * @param name Entrypoint name 
    * @param `value` Json parameters (optional)
    * @return ApiResponse<java.io.File?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsBuildEntrypointParametersGETWithHttpInfo(address: kotlin.String, name: kotlin.String, `value`: kotlin.String?) : ApiResponse<java.io.File?> {
        val localVariableConfig = contractsBuildEntrypointParametersGETRequestConfig(address = address, name = name, `value` = `value`)

        return request<Unit, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsBuildEntrypointParametersGET
    *
    * @param address Contract address 
    * @param name Entrypoint name 
    * @param `value` Json parameters (optional)
    * @return RequestConfig
    */
    fun contractsBuildEntrypointParametersGETRequestConfig(address: kotlin.String, name: kotlin.String, `value`: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (`value` != null) {
                    put("value", listOf(`value`.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/entrypoints/{name}/build".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Build entrypoint parameters
    * Returns micheline parameters converted from its JSON representation.
    * @param address Contract address 
    * @param name Entrypoint name 
    * @param body Json parameters 
    * @return java.io.File
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsBuildEntrypointParametersPOST(address: kotlin.String, name: kotlin.String, body: kotlin.Any) : java.io.File {
        val localVarResponse = contractsBuildEntrypointParametersPOSTWithHttpInfo(address = address, name = name, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Build entrypoint parameters
    * Returns micheline parameters converted from its JSON representation.
    * @param address Contract address 
    * @param name Entrypoint name 
    * @param body Json parameters 
    * @return ApiResponse<java.io.File?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsBuildEntrypointParametersPOSTWithHttpInfo(address: kotlin.String, name: kotlin.String, body: kotlin.Any) : ApiResponse<java.io.File?> {
        val localVariableConfig = contractsBuildEntrypointParametersPOSTRequestConfig(address = address, name = name, body = body)

        return request<kotlin.Any, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsBuildEntrypointParametersPOST
    *
    * @param address Contract address 
    * @param name Entrypoint name 
    * @param body Json parameters 
    * @return RequestConfig
    */
    fun contractsBuildEntrypointParametersPOSTRequestConfig(address: kotlin.String, name: kotlin.String, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/contracts/{address}/entrypoints/{name}/build".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contracts
    * Returns a list of contract accounts.
    * @param kind Contract kind to filter by (&#x60;delegator_contract&#x60; or &#x60;smart_contract&#x60;) (optional)
    * @param creator Filters contracts by creator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;manager&#x60;, &#x60;delegate&#x60;. (optional)
    * @param manager Filters contracts by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;creator&#x60;, &#x60;delegate&#x60;. (optional)
    * @param `delegate` Filters contracts by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;manager&#x60;, &#x60;creator&#x60;. (optional)
    * @param balance Filters contracts by balance (optional)
    * @param lastActivity Filters contracts by last activity level (where the contract was updated) (optional)
    * @param typeHash Filters contracts by 32-bit hash of contract parameter and storage types (helpful for searching similar contracts) (optional)
    * @param codeHash Filters contracts by 32-bit hash of contract code (helpful for searching same contracts) (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return kotlin.collections.List<Contract>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGet(kind: ContractKindParameter?, creator: AccountParameter?, manager: AccountParameter?, `delegate`: AccountParameter?, balance: IntParameter?, lastActivity: IntParameter?, typeHash: IntParameter?, codeHash: IntParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : kotlin.collections.List<Contract> {
        val localVarResponse = contractsGetWithHttpInfo(kind = kind, creator = creator, manager = manager, `delegate` = `delegate`, balance = balance, lastActivity = lastActivity, typeHash = typeHash, codeHash = codeHash, select = select, sort = sort, offset = offset, limit = limit, includeStorage = includeStorage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Contract>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contracts
    * Returns a list of contract accounts.
    * @param kind Contract kind to filter by (&#x60;delegator_contract&#x60; or &#x60;smart_contract&#x60;) (optional)
    * @param creator Filters contracts by creator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;manager&#x60;, &#x60;delegate&#x60;. (optional)
    * @param manager Filters contracts by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;creator&#x60;, &#x60;delegate&#x60;. (optional)
    * @param `delegate` Filters contracts by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;manager&#x60;, &#x60;creator&#x60;. (optional)
    * @param balance Filters contracts by balance (optional)
    * @param lastActivity Filters contracts by last activity level (where the contract was updated) (optional)
    * @param typeHash Filters contracts by 32-bit hash of contract parameter and storage types (helpful for searching similar contracts) (optional)
    * @param codeHash Filters contracts by 32-bit hash of contract code (helpful for searching same contracts) (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return ApiResponse<kotlin.collections.List<Contract>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetWithHttpInfo(kind: ContractKindParameter?, creator: AccountParameter?, manager: AccountParameter?, `delegate`: AccountParameter?, balance: IntParameter?, lastActivity: IntParameter?, typeHash: IntParameter?, codeHash: IntParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<Contract>?> {
        val localVariableConfig = contractsGetRequestConfig(kind = kind, creator = creator, manager = manager, `delegate` = `delegate`, balance = balance, lastActivity = lastActivity, typeHash = typeHash, codeHash = codeHash, select = select, sort = sort, offset = offset, limit = limit, includeStorage = includeStorage)

        return request<Unit, kotlin.collections.List<Contract>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGet
    *
    * @param kind Contract kind to filter by (&#x60;delegator_contract&#x60; or &#x60;smart_contract&#x60;) (optional)
    * @param creator Filters contracts by creator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;manager&#x60;, &#x60;delegate&#x60;. (optional)
    * @param manager Filters contracts by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;creator&#x60;, &#x60;delegate&#x60;. (optional)
    * @param `delegate` Filters contracts by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;manager&#x60;, &#x60;creator&#x60;. (optional)
    * @param balance Filters contracts by balance (optional)
    * @param lastActivity Filters contracts by last activity level (where the contract was updated) (optional)
    * @param typeHash Filters contracts by 32-bit hash of contract parameter and storage types (helpful for searching similar contracts) (optional)
    * @param codeHash Filters contracts by 32-bit hash of contract code (helpful for searching same contracts) (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return RequestConfig
    */
    fun contractsGetRequestConfig(kind: ContractKindParameter?, creator: AccountParameter?, manager: AccountParameter?, `delegate`: AccountParameter?, balance: IntParameter?, lastActivity: IntParameter?, typeHash: IntParameter?, codeHash: IntParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (kind != null) {
                    put("kind", listOf(kind.toString()))
                }
                if (creator != null) {
                    put("creator", listOf(creator.toString()))
                }
                if (manager != null) {
                    put("manager", listOf(manager.toString()))
                }
                if (`delegate` != null) {
                    put("delegate", listOf(`delegate`.toString()))
                }
                if (balance != null) {
                    put("balance", listOf(balance.toString()))
                }
                if (lastActivity != null) {
                    put("lastActivity", listOf(lastActivity.toString()))
                }
                if (typeHash != null) {
                    put("typeHash", listOf(typeHash.toString()))
                }
                if (codeHash != null) {
                    put("codeHash", listOf(codeHash.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeStorage != null) {
                    put("includeStorage", listOf(includeStorage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get bigmap by name
    * Returns contract bigmap with the specified name or storage path.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return BigMap
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetBigMapByName(address: kotlin.String, name: kotlin.String, micheline: MichelineFormat?) : BigMap {
        val localVarResponse = contractsGetBigMapByNameWithHttpInfo(address = address, name = name, micheline = micheline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigMap
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get bigmap by name
    * Returns contract bigmap with the specified name or storage path.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return ApiResponse<BigMap?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetBigMapByNameWithHttpInfo(address: kotlin.String, name: kotlin.String, micheline: MichelineFormat?) : ApiResponse<BigMap?> {
        val localVariableConfig = contractsGetBigMapByNameRequestConfig(address = address, name = name, micheline = micheline)

        return request<Unit, BigMap>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetBigMapByName
    *
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return RequestConfig
    */
    fun contractsGetBigMapByNameRequestConfig(address: kotlin.String, name: kotlin.String, micheline: MichelineFormat?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/bigmaps/{name}".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get bigmap keys
    * Returns keys of a contract bigmap with the specified name.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param active Filters keys by status: &#x60;true&#x60; - active, &#x60;false&#x60; - removed. (optional)
    * @param key Filters keys by JSON key. Note, this query parameter supports the following format: &#x60;?key{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?key.token_id&#x3D;...&#x60;. (optional)
    * @param `value` Filters keys by JSON value. Note, this query parameter supports the following format: &#x60;?value{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?value.balance.gt&#x3D;...&#x60;. (optional)
    * @param lastLevel Filters bigmap keys by the last update level. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmap keys by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;firstLevel&#x60;, &#x60;lastLevel&#x60;, &#x60;updates&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return kotlin.collections.List<BigMapKey>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetBigMapByNameKeys(address: kotlin.String, name: kotlin.String, active: kotlin.Boolean?, key: JsonParameter?, `value`: JsonParameter?, lastLevel: IntParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : kotlin.collections.List<BigMapKey> {
        val localVarResponse = contractsGetBigMapByNameKeysWithHttpInfo(address = address, name = name, active = active, key = key, `value` = `value`, lastLevel = lastLevel, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BigMapKey>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get bigmap keys
    * Returns keys of a contract bigmap with the specified name.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param active Filters keys by status: &#x60;true&#x60; - active, &#x60;false&#x60; - removed. (optional)
    * @param key Filters keys by JSON key. Note, this query parameter supports the following format: &#x60;?key{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?key.token_id&#x3D;...&#x60;. (optional)
    * @param `value` Filters keys by JSON value. Note, this query parameter supports the following format: &#x60;?value{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?value.balance.gt&#x3D;...&#x60;. (optional)
    * @param lastLevel Filters bigmap keys by the last update level. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmap keys by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;firstLevel&#x60;, &#x60;lastLevel&#x60;, &#x60;updates&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return ApiResponse<kotlin.collections.List<BigMapKey>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetBigMapByNameKeysWithHttpInfo(address: kotlin.String, name: kotlin.String, active: kotlin.Boolean?, key: JsonParameter?, `value`: JsonParameter?, lastLevel: IntParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : ApiResponse<kotlin.collections.List<BigMapKey>?> {
        val localVariableConfig = contractsGetBigMapByNameKeysRequestConfig(address = address, name = name, active = active, key = key, `value` = `value`, lastLevel = lastLevel, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return request<Unit, kotlin.collections.List<BigMapKey>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetBigMapByNameKeys
    *
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param active Filters keys by status: &#x60;true&#x60; - active, &#x60;false&#x60; - removed. (optional)
    * @param key Filters keys by JSON key. Note, this query parameter supports the following format: &#x60;?key{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?key.token_id&#x3D;...&#x60;. (optional)
    * @param `value` Filters keys by JSON value. Note, this query parameter supports the following format: &#x60;?value{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?value.balance.gt&#x3D;...&#x60;. (optional)
    * @param lastLevel Filters bigmap keys by the last update level. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmap keys by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;firstLevel&#x60;, &#x60;lastLevel&#x60;, &#x60;updates&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return RequestConfig
    */
    fun contractsGetBigMapByNameKeysRequestConfig(address: kotlin.String, name: kotlin.String, active: kotlin.Boolean?, key: JsonParameter?, `value`: JsonParameter?, lastLevel: IntParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (key != null) {
                    put("key", listOf(key.toString()))
                }
                if (`value` != null) {
                    put("value", listOf(`value`.toString()))
                }
                if (lastLevel != null) {
                    put("lastLevel", listOf(lastLevel.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/bigmaps/{name}/keys".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract bigmaps
    * Returns all active bigmaps allocated in the contract storage.
    * @param address Contract address 
    * @param tags Filters bigmaps tags (&#x60;token_metadata&#x60; - tzip-12, &#x60;metadata&#x60; - tzip-16). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object.             If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmaps by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;firstLevel&#x60;, &#x60;lastLevel&#x60;, &#x60;totalKeys&#x60;, &#x60;activeKeys&#x60;, &#x60;updates&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return kotlin.collections.List<BigMap>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetBigMaps(address: kotlin.String, tags: BigMapTagsParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : kotlin.collections.List<BigMap> {
        val localVarResponse = contractsGetBigMapsWithHttpInfo(address = address, tags = tags, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BigMap>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract bigmaps
    * Returns all active bigmaps allocated in the contract storage.
    * @param address Contract address 
    * @param tags Filters bigmaps tags (&#x60;token_metadata&#x60; - tzip-12, &#x60;metadata&#x60; - tzip-16). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object.             If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmaps by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;firstLevel&#x60;, &#x60;lastLevel&#x60;, &#x60;totalKeys&#x60;, &#x60;activeKeys&#x60;, &#x60;updates&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return ApiResponse<kotlin.collections.List<BigMap>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetBigMapsWithHttpInfo(address: kotlin.String, tags: BigMapTagsParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : ApiResponse<kotlin.collections.List<BigMap>?> {
        val localVariableConfig = contractsGetBigMapsRequestConfig(address = address, tags = tags, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return request<Unit, kotlin.collections.List<BigMap>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetBigMaps
    *
    * @param address Contract address 
    * @param tags Filters bigmaps tags (&#x60;token_metadata&#x60; - tzip-12, &#x60;metadata&#x60; - tzip-16). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object.             If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmaps by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;firstLevel&#x60;, &#x60;lastLevel&#x60;, &#x60;totalKeys&#x60;, &#x60;activeKeys&#x60;, &#x60;updates&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return RequestConfig
    */
    fun contractsGetBigMapsRequestConfig(address: kotlin.String, tags: BigMapTagsParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/bigmaps".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract by address
    * Returns a contract account with the specified address.
    * @param address Contract address (starting with KT) 
    * @return Contract
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetByAddress(address: kotlin.String) : Contract {
        val localVarResponse = contractsGetByAddressWithHttpInfo(address = address)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Contract
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract by address
    * Returns a contract account with the specified address.
    * @param address Contract address (starting with KT) 
    * @return ApiResponse<Contract?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetByAddressWithHttpInfo(address: kotlin.String) : ApiResponse<Contract?> {
        val localVariableConfig = contractsGetByAddressRequestConfig(address = address)

        return request<Unit, Contract>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetByAddress
    *
    * @param address Contract address (starting with KT) 
    * @return RequestConfig
    */
    fun contractsGetByAddressRequestConfig(address: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract code
    * Returns a code of the specified contract.
    * @param address Contract address (starting with KT) 
    * @param level Level at which contract code should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @param format Code format (&#x60;0&#x60; - micheline, &#x60;1&#x60; - michelson, &#x60;2&#x60; - bytes (base64)) (optional, default to 0)
    * @return java.io.File
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetCode(address: kotlin.String, level: kotlin.Int?, format: kotlin.Int?) : java.io.File {
        val localVarResponse = contractsGetCodeWithHttpInfo(address = address, level = level, format = format)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract code
    * Returns a code of the specified contract.
    * @param address Contract address (starting with KT) 
    * @param level Level at which contract code should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @param format Code format (&#x60;0&#x60; - micheline, &#x60;1&#x60; - michelson, &#x60;2&#x60; - bytes (base64)) (optional, default to 0)
    * @return ApiResponse<java.io.File?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetCodeWithHttpInfo(address: kotlin.String, level: kotlin.Int?, format: kotlin.Int?) : ApiResponse<java.io.File?> {
        val localVariableConfig = contractsGetCodeRequestConfig(address = address, level = level, format = format)

        return request<Unit, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetCode
    *
    * @param address Contract address (starting with KT) 
    * @param level Level at which contract code should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @param format Code format (&#x60;0&#x60; - micheline, &#x60;1&#x60; - michelson, &#x60;2&#x60; - bytes (base64)) (optional, default to 0)
    * @return RequestConfig
    */
    fun contractsGetCodeRequestConfig(address: kotlin.String, level: kotlin.Int?, format: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (format != null) {
                    put("format", listOf(format.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/code".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get view by name
    * Returns contract view with specified name.
    * @param address Contract address (starting with KT) 
    * @param name View name 
    * @param json Include parameter and return types in human-readable JSON format (optional, default to true)
    * @param micheline Include parameter and return types in micheline format (optional, default to false)
    * @param michelson Include parameter and return types in michelson format (optional, default to false)
    * @return ContractView
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetContractViewByName(address: kotlin.String, name: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : ContractView {
        val localVarResponse = contractsGetContractViewByNameWithHttpInfo(address = address, name = name, json = json, micheline = micheline, michelson = michelson)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ContractView
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get view by name
    * Returns contract view with specified name.
    * @param address Contract address (starting with KT) 
    * @param name View name 
    * @param json Include parameter and return types in human-readable JSON format (optional, default to true)
    * @param micheline Include parameter and return types in micheline format (optional, default to false)
    * @param michelson Include parameter and return types in michelson format (optional, default to false)
    * @return ApiResponse<ContractView?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetContractViewByNameWithHttpInfo(address: kotlin.String, name: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : ApiResponse<ContractView?> {
        val localVariableConfig = contractsGetContractViewByNameRequestConfig(address = address, name = name, json = json, micheline = micheline, michelson = michelson)

        return request<Unit, ContractView>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetContractViewByName
    *
    * @param address Contract address (starting with KT) 
    * @param name View name 
    * @param json Include parameter and return types in human-readable JSON format (optional, default to true)
    * @param micheline Include parameter and return types in micheline format (optional, default to false)
    * @param michelson Include parameter and return types in michelson format (optional, default to false)
    * @return RequestConfig
    */
    fun contractsGetContractViewByNameRequestConfig(address: kotlin.String, name: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (json != null) {
                    put("json", listOf(json.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (michelson != null) {
                    put("michelson", listOf(michelson.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/views/{name}".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract views
    * Returns all views of the specified contract.
    * @param address Contract address (starting with KT) 
    * @param json Include parameter and return types in human-readable JSON format (optional, default to true)
    * @param micheline Include parameter and return types in micheline format (optional, default to false)
    * @param michelson Include parameter and return types in michelson format (optional, default to false)
    * @return kotlin.collections.List<ContractView>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetContractViews(address: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : kotlin.collections.List<ContractView> {
        val localVarResponse = contractsGetContractViewsWithHttpInfo(address = address, json = json, micheline = micheline, michelson = michelson)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ContractView>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract views
    * Returns all views of the specified contract.
    * @param address Contract address (starting with KT) 
    * @param json Include parameter and return types in human-readable JSON format (optional, default to true)
    * @param micheline Include parameter and return types in micheline format (optional, default to false)
    * @param michelson Include parameter and return types in michelson format (optional, default to false)
    * @return ApiResponse<kotlin.collections.List<ContractView>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetContractViewsWithHttpInfo(address: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<ContractView>?> {
        val localVariableConfig = contractsGetContractViewsRequestConfig(address = address, json = json, micheline = micheline, michelson = michelson)

        return request<Unit, kotlin.collections.List<ContractView>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetContractViews
    *
    * @param address Contract address (starting with KT) 
    * @param json Include parameter and return types in human-readable JSON format (optional, default to true)
    * @param micheline Include parameter and return types in micheline format (optional, default to false)
    * @param michelson Include parameter and return types in michelson format (optional, default to false)
    * @return RequestConfig
    */
    fun contractsGetContractViewsRequestConfig(address: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (json != null) {
                    put("json", listOf(json.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (michelson != null) {
                    put("michelson", listOf(michelson.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/views".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contracts count
    * Returns a number of contract accounts.
    * @param kind Contract kind to filter by (&#x60;delegator_contract&#x60; or &#x60;smart_contract&#x60;) (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetCount(kind: ContractKindParameter?) : kotlin.Int {
        val localVarResponse = contractsGetCountWithHttpInfo(kind = kind)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contracts count
    * Returns a number of contract accounts.
    * @param kind Contract kind to filter by (&#x60;delegator_contract&#x60; or &#x60;smart_contract&#x60;) (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetCountWithHttpInfo(kind: ContractKindParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = contractsGetCountRequestConfig(kind = kind)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetCount
    *
    * @param kind Contract kind to filter by (&#x60;delegator_contract&#x60; or &#x60;smart_contract&#x60;) (optional)
    * @return RequestConfig
    */
    fun contractsGetCountRequestConfig(kind: ContractKindParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (kind != null) {
                    put("kind", listOf(kind.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get entrypoint by name
    * Returns contract&#39;s entrypoint with specified name.
    * @param address Contract address (starting with KT) 
    * @param name Entrypoint name 
    * @param json Include parameters schema in human-readable JSON format (optional, default to true)
    * @param micheline Include parameters schema in micheline format (optional, default to false)
    * @param michelson Include parameters schema in michelson format (optional, default to false)
    * @return Entrypoint
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetEntrypointByName(address: kotlin.String, name: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : Entrypoint {
        val localVarResponse = contractsGetEntrypointByNameWithHttpInfo(address = address, name = name, json = json, micheline = micheline, michelson = michelson)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Entrypoint
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get entrypoint by name
    * Returns contract&#39;s entrypoint with specified name.
    * @param address Contract address (starting with KT) 
    * @param name Entrypoint name 
    * @param json Include parameters schema in human-readable JSON format (optional, default to true)
    * @param micheline Include parameters schema in micheline format (optional, default to false)
    * @param michelson Include parameters schema in michelson format (optional, default to false)
    * @return ApiResponse<Entrypoint?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetEntrypointByNameWithHttpInfo(address: kotlin.String, name: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : ApiResponse<Entrypoint?> {
        val localVariableConfig = contractsGetEntrypointByNameRequestConfig(address = address, name = name, json = json, micheline = micheline, michelson = michelson)

        return request<Unit, Entrypoint>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetEntrypointByName
    *
    * @param address Contract address (starting with KT) 
    * @param name Entrypoint name 
    * @param json Include parameters schema in human-readable JSON format (optional, default to true)
    * @param micheline Include parameters schema in micheline format (optional, default to false)
    * @param michelson Include parameters schema in michelson format (optional, default to false)
    * @return RequestConfig
    */
    fun contractsGetEntrypointByNameRequestConfig(address: kotlin.String, name: kotlin.String, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (json != null) {
                    put("json", listOf(json.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (michelson != null) {
                    put("michelson", listOf(michelson.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/entrypoints/{name}".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract entrypoints
    * Returns entrypoints of the specified contract.
    * @param address Contract address (starting with KT) 
    * @param all If true, returns all entrypoints, including unused ones.             Unused means that the entrypoint can be normalized to a more specific one.             For example here &#x60;(or %entry1 (unit %entry2) (nat %entry3))&#x60; the &#x60;%entry1&#x60; is unused entrypoint             because it can be normalized to &#x60;%entry2&#x60; or &#x60;%entry3&#x60; (optional, default to false)
    * @param json Include parameters schema in human-readable JSON format (optional, default to true)
    * @param micheline Include parameters schema in micheline format (optional, default to false)
    * @param michelson Include parameters schema in michelson format (optional, default to false)
    * @return kotlin.collections.List<Entrypoint>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetEntrypoints(address: kotlin.String, all: kotlin.Boolean?, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : kotlin.collections.List<Entrypoint> {
        val localVarResponse = contractsGetEntrypointsWithHttpInfo(address = address, all = all, json = json, micheline = micheline, michelson = michelson)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Entrypoint>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract entrypoints
    * Returns entrypoints of the specified contract.
    * @param address Contract address (starting with KT) 
    * @param all If true, returns all entrypoints, including unused ones.             Unused means that the entrypoint can be normalized to a more specific one.             For example here &#x60;(or %entry1 (unit %entry2) (nat %entry3))&#x60; the &#x60;%entry1&#x60; is unused entrypoint             because it can be normalized to &#x60;%entry2&#x60; or &#x60;%entry3&#x60; (optional, default to false)
    * @param json Include parameters schema in human-readable JSON format (optional, default to true)
    * @param micheline Include parameters schema in micheline format (optional, default to false)
    * @param michelson Include parameters schema in michelson format (optional, default to false)
    * @return ApiResponse<kotlin.collections.List<Entrypoint>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetEntrypointsWithHttpInfo(address: kotlin.String, all: kotlin.Boolean?, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<Entrypoint>?> {
        val localVariableConfig = contractsGetEntrypointsRequestConfig(address = address, all = all, json = json, micheline = micheline, michelson = michelson)

        return request<Unit, kotlin.collections.List<Entrypoint>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetEntrypoints
    *
    * @param address Contract address (starting with KT) 
    * @param all If true, returns all entrypoints, including unused ones.             Unused means that the entrypoint can be normalized to a more specific one.             For example here &#x60;(or %entry1 (unit %entry2) (nat %entry3))&#x60; the &#x60;%entry1&#x60; is unused entrypoint             because it can be normalized to &#x60;%entry2&#x60; or &#x60;%entry3&#x60; (optional, default to false)
    * @param json Include parameters schema in human-readable JSON format (optional, default to true)
    * @param micheline Include parameters schema in micheline format (optional, default to false)
    * @param michelson Include parameters schema in michelson format (optional, default to false)
    * @return RequestConfig
    */
    fun contractsGetEntrypointsRequestConfig(address: kotlin.String, all: kotlin.Boolean?, json: kotlin.Boolean?, micheline: kotlin.Boolean?, michelson: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (all != null) {
                    put("all", listOf(all.toString()))
                }
                if (json != null) {
                    put("json", listOf(json.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (michelson != null) {
                    put("michelson", listOf(michelson.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/entrypoints".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get historical keys
    * Returns a list of bigmap keys at the specific block.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param level Level of the block at which you want to get bigmap keys 
    * @param active Filters keys by status: &#x60;true&#x60; - active, &#x60;false&#x60; - removed. (optional)
    * @param key Filters keys by JSON key. Note, this query parameter supports the following format: &#x60;?key{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?key.token_id&#x3D;...&#x60;. (optional)
    * @param `value` Filters keys by JSON value. Note, this query parameter supports the following format: &#x60;?value{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?value.balance.gt&#x3D;...&#x60;. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmap keys by specified field. Supported fields: &#x60;id&#x60; (default). (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return kotlin.collections.List<BigMapKeyHistorical>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetHistoricalKeys(address: kotlin.String, name: kotlin.String, level: kotlin.Int, active: kotlin.Boolean?, key: JsonParameter?, `value`: JsonParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : kotlin.collections.List<BigMapKeyHistorical> {
        val localVarResponse = contractsGetHistoricalKeysWithHttpInfo(address = address, name = name, level = level, active = active, key = key, `value` = `value`, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BigMapKeyHistorical>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get historical keys
    * Returns a list of bigmap keys at the specific block.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param level Level of the block at which you want to get bigmap keys 
    * @param active Filters keys by status: &#x60;true&#x60; - active, &#x60;false&#x60; - removed. (optional)
    * @param key Filters keys by JSON key. Note, this query parameter supports the following format: &#x60;?key{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?key.token_id&#x3D;...&#x60;. (optional)
    * @param `value` Filters keys by JSON value. Note, this query parameter supports the following format: &#x60;?value{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?value.balance.gt&#x3D;...&#x60;. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmap keys by specified field. Supported fields: &#x60;id&#x60; (default). (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return ApiResponse<kotlin.collections.List<BigMapKeyHistorical>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetHistoricalKeysWithHttpInfo(address: kotlin.String, name: kotlin.String, level: kotlin.Int, active: kotlin.Boolean?, key: JsonParameter?, `value`: JsonParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : ApiResponse<kotlin.collections.List<BigMapKeyHistorical>?> {
        val localVariableConfig = contractsGetHistoricalKeysRequestConfig(address = address, name = name, level = level, active = active, key = key, `value` = `value`, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return request<Unit, kotlin.collections.List<BigMapKeyHistorical>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetHistoricalKeys
    *
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param level Level of the block at which you want to get bigmap keys 
    * @param active Filters keys by status: &#x60;true&#x60; - active, &#x60;false&#x60; - removed. (optional)
    * @param key Filters keys by JSON key. Note, this query parameter supports the following format: &#x60;?key{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?key.token_id&#x3D;...&#x60;. (optional)
    * @param `value` Filters keys by JSON value. Note, this query parameter supports the following format: &#x60;?value{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?value.balance.gt&#x3D;...&#x60;. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts bigmap keys by specified field. Supported fields: &#x60;id&#x60; (default). (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return RequestConfig
    */
    fun contractsGetHistoricalKeysRequestConfig(address: kotlin.String, name: kotlin.String, level: kotlin.Int, active: kotlin.Boolean?, key: JsonParameter?, `value`: JsonParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (key != null) {
                    put("key", listOf(key.toString()))
                }
                if (`value` != null) {
                    put("value", listOf(`value`.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/bigmaps/{name}/historical_keys/{level}".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name").replace("{"+"level"+"}", "$level"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get JSON Schema [2020-12] interface for the contract
    * Returns standard JSON Schema for contract storage, entrypoints, and Big_map entries.
    * @param address Contract address 
    * @return ContractInterface
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetInterface(address: kotlin.String) : ContractInterface {
        val localVarResponse = contractsGetInterfaceWithHttpInfo(address = address)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ContractInterface
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get JSON Schema [2020-12] interface for the contract
    * Returns standard JSON Schema for contract storage, entrypoints, and Big_map entries.
    * @param address Contract address 
    * @return ApiResponse<ContractInterface?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetInterfaceWithHttpInfo(address: kotlin.String) : ApiResponse<ContractInterface?> {
        val localVariableConfig = contractsGetInterfaceRequestConfig(address = address)

        return request<Unit, ContractInterface>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetInterface
    *
    * @param address Contract address 
    * @return RequestConfig
    */
    fun contractsGetInterfaceRequestConfig(address: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/interface".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get bigmap key
    * Returns the specified bigmap key.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return BigMapKey
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetKey(address: kotlin.String, name: kotlin.String, key: kotlin.String, micheline: MichelineFormat?) : BigMapKey {
        val localVarResponse = contractsGetKeyWithHttpInfo(address = address, name = name, key = key, micheline = micheline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigMapKey
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get bigmap key
    * Returns the specified bigmap key.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return ApiResponse<BigMapKey?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetKeyWithHttpInfo(address: kotlin.String, name: kotlin.String, key: kotlin.String, micheline: MichelineFormat?) : ApiResponse<BigMapKey?> {
        val localVariableConfig = contractsGetKeyRequestConfig(address = address, name = name, key = key, micheline = micheline)

        return request<Unit, BigMapKey>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetKey
    *
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return RequestConfig
    */
    fun contractsGetKeyRequestConfig(address: kotlin.String, name: kotlin.String, key: kotlin.String, micheline: MichelineFormat?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/bigmaps/{name}/keys/{key}".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name").replace("{"+"key"+"}", "$key"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get historical key
    * Returns the specified bigmap key at the specific block.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param level Level of the block at which you want to get bigmap key 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return BigMapKeyHistorical
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetKey2(address: kotlin.String, name: kotlin.String, level: kotlin.Int, key: kotlin.String, micheline: MichelineFormat?) : BigMapKeyHistorical {
        val localVarResponse = contractsGetKey2WithHttpInfo(address = address, name = name, level = level, key = key, micheline = micheline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigMapKeyHistorical
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get historical key
    * Returns the specified bigmap key at the specific block.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param level Level of the block at which you want to get bigmap key 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return ApiResponse<BigMapKeyHistorical?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetKey2WithHttpInfo(address: kotlin.String, name: kotlin.String, level: kotlin.Int, key: kotlin.String, micheline: MichelineFormat?) : ApiResponse<BigMapKeyHistorical?> {
        val localVariableConfig = contractsGetKey2RequestConfig(address = address, name = name, level = level, key = key, micheline = micheline)

        return request<Unit, BigMapKeyHistorical>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetKey2
    *
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param level Level of the block at which you want to get bigmap key 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param micheline Format of the bigmap key and value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return RequestConfig
    */
    fun contractsGetKey2RequestConfig(address: kotlin.String, name: kotlin.String, level: kotlin.Int, key: kotlin.String, micheline: MichelineFormat?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/bigmaps/{name}/historical_keys/{level}/{key}".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name").replace("{"+"level"+"}", "$level").replace("{"+"key"+"}", "$key"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get bigmap key updates
    * Returns updates history for the specified bigmap key.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param sort Sorts bigmap updates by specified field. Supported fields: &#x60;id&#x60; (default). (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the key value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return kotlin.collections.List<BigMapKeyUpdate>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetKeyUpdates(address: kotlin.String, name: kotlin.String, key: kotlin.String, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : kotlin.collections.List<BigMapKeyUpdate> {
        val localVarResponse = contractsGetKeyUpdatesWithHttpInfo(address = address, name = name, key = key, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BigMapKeyUpdate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get bigmap key updates
    * Returns updates history for the specified bigmap key.
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param sort Sorts bigmap updates by specified field. Supported fields: &#x60;id&#x60; (default). (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the key value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return ApiResponse<kotlin.collections.List<BigMapKeyUpdate>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetKeyUpdatesWithHttpInfo(address: kotlin.String, name: kotlin.String, key: kotlin.String, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : ApiResponse<kotlin.collections.List<BigMapKeyUpdate>?> {
        val localVariableConfig = contractsGetKeyUpdatesRequestConfig(address = address, name = name, key = key, sort = sort, offset = offset, limit = limit, micheline = micheline)

        return request<Unit, kotlin.collections.List<BigMapKeyUpdate>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetKeyUpdates
    *
    * @param address Contract address 
    * @param name Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is &#x60;ledger&#x60; or &#x60;assets.ledger&#x60;, then the name is &#x60;ledger&#x60;.             If there are multiple bigmaps with the same name, for example &#x60;assets.ledger&#x60; and &#x60;tokens.ledger&#x60;, you can specify the full path. 
    * @param key Either a key hash (&#x60;expr123...&#x60;) or a plain value (&#x60;abcde...&#x60;).             Even if the key is complex (an object or an array), you can specify it as is, for example, &#x60;/keys/{\&quot;address\&quot;:\&quot;tz123\&quot;,\&quot;nat\&quot;:\&quot;123\&quot;}&#x60;. 
    * @param sort Sorts bigmap updates by specified field. Supported fields: &#x60;id&#x60; (default). (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the key value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - Micheline, &#x60;3&#x60; - Micheline string (optional)
    * @return RequestConfig
    */
    fun contractsGetKeyUpdatesRequestConfig(address: kotlin.String, name: kotlin.String, key: kotlin.String, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/bigmaps/{name}/keys/{key}/updates".replace("{"+"address"+"}", "$address").replace("{"+"name"+"}", "$name").replace("{"+"key"+"}", "$key"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get raw contract storage
    * Returns raw contract storage value in micheline format.
    * @param address Contract address 
    * @param level Level at which storage value should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @return IMicheline
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetRawStorage(address: kotlin.String, level: kotlin.Int?) : IMicheline {
        val localVarResponse = contractsGetRawStorageWithHttpInfo(address = address, level = level)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IMicheline
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get raw contract storage
    * Returns raw contract storage value in micheline format.
    * @param address Contract address 
    * @param level Level at which storage value should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @return ApiResponse<IMicheline?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetRawStorageWithHttpInfo(address: kotlin.String, level: kotlin.Int?) : ApiResponse<IMicheline?> {
        val localVariableConfig = contractsGetRawStorageRequestConfig(address = address, level = level)

        return request<Unit, IMicheline>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetRawStorage
    *
    * @param address Contract address 
    * @param level Level at which storage value should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @return RequestConfig
    */
    fun contractsGetRawStorageRequestConfig(address: kotlin.String, level: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/storage/raw".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get raw contract storage history
    * Returns raw contract storage historical values.
    * @param address Contract address 
    * @param lastId Id of the last item received (for pagination) (optional, default to 0)
    * @param limit Maximum number of items to return (optional, default to 10)
    * @return kotlin.collections.List<StorageRecord>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetRawStorageHistory(address: kotlin.String, lastId: kotlin.Int?, limit: kotlin.Int?) : kotlin.collections.List<StorageRecord> {
        val localVarResponse = contractsGetRawStorageHistoryWithHttpInfo(address = address, lastId = lastId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<StorageRecord>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get raw contract storage history
    * Returns raw contract storage historical values.
    * @param address Contract address 
    * @param lastId Id of the last item received (for pagination) (optional, default to 0)
    * @param limit Maximum number of items to return (optional, default to 10)
    * @return ApiResponse<kotlin.collections.List<StorageRecord>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetRawStorageHistoryWithHttpInfo(address: kotlin.String, lastId: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<StorageRecord>?> {
        val localVariableConfig = contractsGetRawStorageHistoryRequestConfig(address = address, lastId = lastId, limit = limit)

        return request<Unit, kotlin.collections.List<StorageRecord>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetRawStorageHistory
    *
    * @param address Contract address 
    * @param lastId Id of the last item received (for pagination) (optional, default to 0)
    * @param limit Maximum number of items to return (optional, default to 10)
    * @return RequestConfig
    */
    fun contractsGetRawStorageHistoryRequestConfig(address: kotlin.String, lastId: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (lastId != null) {
                    put("lastId", listOf(lastId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/storage/raw/history".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get raw contract storage schema
    * Returns micheline schema (type) of the contract storage.
    * @param address Contract address 
    * @param level Level at which storage schema should be taken. If &#x60;0&#x60; or not specified, the current schema will be returned. (optional, default to 0)
    * @return IMicheline
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetRawStorageSchema(address: kotlin.String, level: kotlin.Int?) : IMicheline {
        val localVarResponse = contractsGetRawStorageSchemaWithHttpInfo(address = address, level = level)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IMicheline
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get raw contract storage schema
    * Returns micheline schema (type) of the contract storage.
    * @param address Contract address 
    * @param level Level at which storage schema should be taken. If &#x60;0&#x60; or not specified, the current schema will be returned. (optional, default to 0)
    * @return ApiResponse<IMicheline?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetRawStorageSchemaWithHttpInfo(address: kotlin.String, level: kotlin.Int?) : ApiResponse<IMicheline?> {
        val localVariableConfig = contractsGetRawStorageSchemaRequestConfig(address = address, level = level)

        return request<Unit, IMicheline>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetRawStorageSchema
    *
    * @param address Contract address 
    * @param level Level at which storage schema should be taken. If &#x60;0&#x60; or not specified, the current schema will be returned. (optional, default to 0)
    * @return RequestConfig
    */
    fun contractsGetRawStorageSchemaRequestConfig(address: kotlin.String, level: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/storage/raw/schema".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get same contracts
    * Returns contracts which have the same script as the specified one. Note, contract scripts are compared by 32-bit hash, so in very rare cases there may be collisions.
    * @param address Contract address (starting with KT) 
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return kotlin.collections.List<Contract>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetSame(address: kotlin.String, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : kotlin.collections.List<Contract> {
        val localVarResponse = contractsGetSameWithHttpInfo(address = address, select = select, sort = sort, offset = offset, limit = limit, includeStorage = includeStorage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Contract>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get same contracts
    * Returns contracts which have the same script as the specified one. Note, contract scripts are compared by 32-bit hash, so in very rare cases there may be collisions.
    * @param address Contract address (starting with KT) 
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return ApiResponse<kotlin.collections.List<Contract>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetSameWithHttpInfo(address: kotlin.String, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<Contract>?> {
        val localVariableConfig = contractsGetSameRequestConfig(address = address, select = select, sort = sort, offset = offset, limit = limit, includeStorage = includeStorage)

        return request<Unit, kotlin.collections.List<Contract>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetSame
    *
    * @param address Contract address (starting with KT) 
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return RequestConfig
    */
    fun contractsGetSameRequestConfig(address: kotlin.String, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeStorage != null) {
                    put("includeStorage", listOf(includeStorage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/same".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get similar contracts
    * Returns contracts which have the same interface (parameter and storage types) as the specified one. Note, contract parameter and storage types are compared by 32-bit hash, so in very rare cases there may be collisions.
    * @param address Contract address (starting with KT) 
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return kotlin.collections.List<Contract>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetSimilar(address: kotlin.String, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : kotlin.collections.List<Contract> {
        val localVarResponse = contractsGetSimilarWithHttpInfo(address = address, select = select, sort = sort, offset = offset, limit = limit, includeStorage = includeStorage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Contract>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get similar contracts
    * Returns contracts which have the same interface (parameter and storage types) as the specified one. Note, contract parameter and storage types are compared by 32-bit hash, so in very rare cases there may be collisions.
    * @param address Contract address (starting with KT) 
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return ApiResponse<kotlin.collections.List<Contract>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetSimilarWithHttpInfo(address: kotlin.String, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<Contract>?> {
        val localVariableConfig = contractsGetSimilarRequestConfig(address = address, select = select, sort = sort, offset = offset, limit = limit, includeStorage = includeStorage)

        return request<Unit, kotlin.collections.List<Contract>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetSimilar
    *
    * @param address Contract address (starting with KT) 
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts contracts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;balance&#x60;, &#x60;firstActivity&#x60;, &#x60;lastActivity&#x60;, &#x60;numTransactions&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param includeStorage Specifies whether to include contract storage value in response. (optional, default to false)
    * @return RequestConfig
    */
    fun contractsGetSimilarRequestConfig(address: kotlin.String, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, includeStorage: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeStorage != null) {
                    put("includeStorage", listOf(includeStorage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/similar".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract storage
    * Returns contract storage value in JSON format.
    * @param address Contract address 
    * @param level Level at which storage value should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @param path Path in the JSON value (point-separated list of field names, e.g. &#x60;path&#x3D;settings.refund_time&#x60; to return (optional)
    * @return java.io.File
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetStorage(address: kotlin.String, level: kotlin.Int?, path: kotlin.String?) : java.io.File {
        val localVarResponse = contractsGetStorageWithHttpInfo(address = address, level = level, path = path)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract storage
    * Returns contract storage value in JSON format.
    * @param address Contract address 
    * @param level Level at which storage value should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @param path Path in the JSON value (point-separated list of field names, e.g. &#x60;path&#x3D;settings.refund_time&#x60; to return (optional)
    * @return ApiResponse<java.io.File?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetStorageWithHttpInfo(address: kotlin.String, level: kotlin.Int?, path: kotlin.String?) : ApiResponse<java.io.File?> {
        val localVariableConfig = contractsGetStorageRequestConfig(address = address, level = level, path = path)

        return request<Unit, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetStorage
    *
    * @param address Contract address 
    * @param level Level at which storage value should be taken. If &#x60;0&#x60; or not specified, the current value will be returned. (optional, default to 0)
    * @param path Path in the JSON value (point-separated list of field names, e.g. &#x60;path&#x3D;settings.refund_time&#x60; to return (optional)
    * @return RequestConfig
    */
    fun contractsGetStorageRequestConfig(address: kotlin.String, level: kotlin.Int?, path: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (path != null) {
                    put("path", listOf(path.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/storage".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract storage history
    * Returns contract storage historical values.
    * @param address Contract address 
    * @param lastId Id of the last item received (for pagination) (optional, default to 0)
    * @param limit Maximum number of items to return (optional, default to 10)
    * @return kotlin.collections.List<StorageRecord>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetStorageHistory(address: kotlin.String, lastId: kotlin.Int?, limit: kotlin.Int?) : kotlin.collections.List<StorageRecord> {
        val localVarResponse = contractsGetStorageHistoryWithHttpInfo(address = address, lastId = lastId, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<StorageRecord>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract storage history
    * Returns contract storage historical values.
    * @param address Contract address 
    * @param lastId Id of the last item received (for pagination) (optional, default to 0)
    * @param limit Maximum number of items to return (optional, default to 10)
    * @return ApiResponse<kotlin.collections.List<StorageRecord>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetStorageHistoryWithHttpInfo(address: kotlin.String, lastId: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<StorageRecord>?> {
        val localVariableConfig = contractsGetStorageHistoryRequestConfig(address = address, lastId = lastId, limit = limit)

        return request<Unit, kotlin.collections.List<StorageRecord>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetStorageHistory
    *
    * @param address Contract address 
    * @param lastId Id of the last item received (for pagination) (optional, default to 0)
    * @param limit Maximum number of items to return (optional, default to 10)
    * @return RequestConfig
    */
    fun contractsGetStorageHistoryRequestConfig(address: kotlin.String, lastId: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (lastId != null) {
                    put("lastId", listOf(lastId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/storage/history".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get contract storage schema
    * Returns JSON schema of the contract storage.
    * @param address Contract address 
    * @param level Level at which storage schema should be taken. If &#x60;0&#x60; or not specified, the current schema will be returned. (optional, default to 0)
    * @return java.io.File
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractsGetStorageSchema(address: kotlin.String, level: kotlin.Int?) : java.io.File {
        val localVarResponse = contractsGetStorageSchemaWithHttpInfo(address = address, level = level)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get contract storage schema
    * Returns JSON schema of the contract storage.
    * @param address Contract address 
    * @param level Level at which storage schema should be taken. If &#x60;0&#x60; or not specified, the current schema will be returned. (optional, default to 0)
    * @return ApiResponse<java.io.File?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractsGetStorageSchemaWithHttpInfo(address: kotlin.String, level: kotlin.Int?) : ApiResponse<java.io.File?> {
        val localVariableConfig = contractsGetStorageSchemaRequestConfig(address = address, level = level)

        return request<Unit, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation contractsGetStorageSchema
    *
    * @param address Contract address 
    * @param level Level at which storage schema should be taken. If &#x60;0&#x60; or not specified, the current schema will be returned. (optional, default to 0)
    * @return RequestConfig
    */
    fun contractsGetStorageSchemaRequestConfig(address: kotlin.String, level: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/contracts/{address}/storage/schema".replace("{"+"address"+"}", "$address"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
