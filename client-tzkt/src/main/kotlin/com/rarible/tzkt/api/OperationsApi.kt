/**
 * TzKT API
 *
 * # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Granadanet: `https://api.granadanet.tzkt.io/` ([view docs](https://api.granadanet.tzkt.io))     - Hangzhou2net: `https://api.hangzhou2net.tzkt.io/` ([view docs](https://api.hangzhou2net.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://staging.api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://staging.api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@baking-bad.org  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you should mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  --- 
 *
 * The version of the OpenAPI document: v1.7.0
 * Contact: hello@baking-bad.org
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.rarible.tzkt.api

import com.rarible.tzkt.infrastructure.ApiClient
import com.rarible.tzkt.infrastructure.ApiResponse
import com.rarible.tzkt.infrastructure.ClientError
import com.rarible.tzkt.infrastructure.ClientException
import com.rarible.tzkt.infrastructure.MultiValueMap
import com.rarible.tzkt.infrastructure.RequestConfig
import com.rarible.tzkt.infrastructure.RequestMethod
import com.rarible.tzkt.infrastructure.ResponseType
import com.rarible.tzkt.infrastructure.ServerError
import com.rarible.tzkt.infrastructure.ServerException
import com.rarible.tzkt.infrastructure.Success
import com.rarible.tzkt.models.AccountParameter
import com.rarible.tzkt.models.ActivationOperation
import com.rarible.tzkt.models.BakingOperation
import com.rarible.tzkt.models.BallotOperation
import com.rarible.tzkt.models.BoolParameter
import com.rarible.tzkt.models.DateTimeParameter
import com.rarible.tzkt.models.DelegationOperation
import com.rarible.tzkt.models.DoubleBakingOperation
import com.rarible.tzkt.models.DoubleEndorsingOperation
import com.rarible.tzkt.models.EndorsementOperation
import com.rarible.tzkt.models.ExpressionParameter
import com.rarible.tzkt.models.IntParameter
import com.rarible.tzkt.models.JsonParameter
import com.rarible.tzkt.models.MichelineFormat
import com.rarible.tzkt.models.MigrationKindParameter
import com.rarible.tzkt.models.MigrationOperation
import com.rarible.tzkt.models.NonceRevelationOperation
import com.rarible.tzkt.models.OffsetParameter
import com.rarible.tzkt.models.Operation
import com.rarible.tzkt.models.OperationStatusParameter
import com.rarible.tzkt.models.OriginationOperation
import com.rarible.tzkt.models.ProposalOperation
import com.rarible.tzkt.models.ProtocolParameter
import com.rarible.tzkt.models.RegisterConstantOperation
import com.rarible.tzkt.models.RevealOperation
import com.rarible.tzkt.models.RevelationPenaltyOperation
import com.rarible.tzkt.models.SelectParameter
import com.rarible.tzkt.models.SortParameter
import com.rarible.tzkt.models.StringParameter
import com.rarible.tzkt.models.Symbols
import com.rarible.tzkt.models.TransactionOperation
import java.io.IOException

class OperationsApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://staging.api.tzkt.io")
        }
    }

    /**
    * Get activation by hash
    * Returns an activation operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<ActivationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetActivationByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<ActivationOperation> {
        val localVarResponse = operationsGetActivationByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ActivationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get activation by hash
    * Returns an activation operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<ActivationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetActivationByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<List<ActivationOperation>?> {
        val localVariableConfig = operationsGetActivationByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<ActivationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetActivationByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetActivationByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/activations/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get activations
    * Returns a list of activation operations.
    * @param account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters activations by level. (optional)
    * @param timestamp Filters activations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<ActivationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetActivations(account: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<ActivationOperation> {
        val localVarResponse = operationsGetActivationsWithHttpInfo(account = account, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ActivationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get activations
    * Returns a list of activation operations.
    * @param account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters activations by level. (optional)
    * @param timestamp Filters activations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<ActivationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetActivationsWithHttpInfo(account: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<ActivationOperation>?> {
        val localVariableConfig = operationsGetActivationsRequestConfig(account = account, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<ActivationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetActivations
    *
    * @param account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters activations by level. (optional)
    * @param timestamp Filters activations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetActivationsRequestConfig(account: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (account != null) {
                    put("account", listOf(account.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/activations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get activations count
    * Returns the total number of activation operations.
    * @param level Filters activations by level. (optional)
    * @param timestamp Filters activations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetActivationsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetActivationsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get activations count
    * Returns the total number of activation operations.
    * @param level Filters activations by level. (optional)
    * @param timestamp Filters activations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetActivationsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetActivationsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetActivationsCount
    *
    * @param level Filters activations by level. (optional)
    * @param timestamp Filters activations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetActivationsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/activations/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get baking
    * Returns a list of baking operations (synthetic type).
    * @param baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters baking operations by level. (optional)
    * @param timestamp Filters baking operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<BakingOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetBaking(baker: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<BakingOperation> {
        val localVarResponse = operationsGetBakingWithHttpInfo(baker = baker, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BakingOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get baking
    * Returns a list of baking operations (synthetic type).
    * @param baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters baking operations by level. (optional)
    * @param timestamp Filters baking operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<BakingOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetBakingWithHttpInfo(baker: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<BakingOperation>?> {
        val localVariableConfig = operationsGetBakingRequestConfig(baker = baker, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<BakingOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetBaking
    *
    * @param baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters baking operations by level. (optional)
    * @param timestamp Filters baking operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetBakingRequestConfig(baker: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (baker != null) {
                    put("baker", listOf(baker.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/baking",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get baking by id
    * Returns baking operation with specified id.
    * @param id Operation id 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return BakingOperation
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetBakingById(id: kotlin.Int, quote: Symbols?) : BakingOperation {
        val localVarResponse = operationsGetBakingByIdWithHttpInfo(id = id, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BakingOperation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get baking by id
    * Returns baking operation with specified id.
    * @param id Operation id 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<BakingOperation?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetBakingByIdWithHttpInfo(id: kotlin.Int, quote: Symbols?) : ApiResponse<BakingOperation?> {
        val localVariableConfig = operationsGetBakingByIdRequestConfig(id = id, quote = quote)

        return request<Unit, BakingOperation>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetBakingById
    *
    * @param id Operation id 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetBakingByIdRequestConfig(id: kotlin.Int, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/baking/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get baking count
    * Returns the total number of baking operations (synthetic type).
    * @param level Filters baking operations by level. (optional)
    * @param timestamp Filters baking operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetBakingCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetBakingCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get baking count
    * Returns the total number of baking operations (synthetic type).
    * @param level Filters baking operations by level. (optional)
    * @param timestamp Filters baking operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetBakingCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetBakingCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetBakingCount
    *
    * @param level Filters baking operations by level. (optional)
    * @param timestamp Filters baking operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetBakingCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/baking/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get ballot by hash
    * Returns a ballot operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<BallotOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetBallotByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<BallotOperation> {
        val localVarResponse = operationsGetBallotByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BallotOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get ballot by hash
    * Returns a ballot operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<BallotOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetBallotByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<BallotOperation>?> {
        val localVariableConfig = operationsGetBallotByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<BallotOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetBallotByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetBallotByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/ballots/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get ballots
    * Returns a list of ballot operations.
    * @param `delegate` Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters ballots by level. (optional)
    * @param timestamp Filters ballots by timestamp. (optional)
    * @param epoch Filters ballots by voting epoch. (optional)
    * @param period Filters ballots by voting period. (optional)
    * @param proposal Filters ballots by proposal hash. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<BallotOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetBallots(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, epoch: IntParameter?, period: IntParameter?, proposal: ProtocolParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<BallotOperation> {
        val localVarResponse = operationsGetBallotsWithHttpInfo(`delegate` = `delegate`, level = level, timestamp = timestamp, epoch = epoch, period = period, proposal = proposal, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BallotOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get ballots
    * Returns a list of ballot operations.
    * @param `delegate` Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters ballots by level. (optional)
    * @param timestamp Filters ballots by timestamp. (optional)
    * @param epoch Filters ballots by voting epoch. (optional)
    * @param period Filters ballots by voting period. (optional)
    * @param proposal Filters ballots by proposal hash. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<BallotOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetBallotsWithHttpInfo(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, epoch: IntParameter?, period: IntParameter?, proposal: ProtocolParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<BallotOperation>?> {
        val localVariableConfig = operationsGetBallotsRequestConfig(`delegate` = `delegate`, level = level, timestamp = timestamp, epoch = epoch, period = period, proposal = proposal, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<BallotOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetBallots
    *
    * @param `delegate` Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters ballots by level. (optional)
    * @param timestamp Filters ballots by timestamp. (optional)
    * @param epoch Filters ballots by voting epoch. (optional)
    * @param period Filters ballots by voting period. (optional)
    * @param proposal Filters ballots by proposal hash. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetBallotsRequestConfig(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, epoch: IntParameter?, period: IntParameter?, proposal: ProtocolParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (`delegate` != null) {
                    put("delegate", listOf(`delegate`.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (epoch != null) {
                    put("epoch", listOf(epoch.toString()))
                }
                if (period != null) {
                    put("period", listOf(period.toString()))
                }
                if (proposal != null) {
                    put("proposal", listOf(proposal.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/ballots",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get ballots count
    * Returns the total number of ballot operations.
    * @param level Filters ballot operations by level. (optional)
    * @param timestamp Filters ballot operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetBallotsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetBallotsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get ballots count
    * Returns the total number of ballot operations.
    * @param level Filters ballot operations by level. (optional)
    * @param timestamp Filters ballot operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetBallotsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetBallotsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetBallotsCount
    *
    * @param level Filters ballot operations by level. (optional)
    * @param timestamp Filters ballot operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetBallotsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/ballots/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get operations by hash
    * Returns a list of operations with the specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<Operation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetByHash(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<Operation> {
        val localVarResponse = operationsGetByHashWithHttpInfo(hash = hash, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Operation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get operations by hash
    * Returns a list of operations with the specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<Operation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetByHashWithHttpInfo(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<Operation>?> {
        val localVariableConfig = operationsGetByHashRequestConfig(hash = hash, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<Operation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetByHash
    *
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetByHashRequestConfig(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get operations by hash and counter
    * Returns a list of operations with the specified hash and counter.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<Operation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetByHashCounter(hash: kotlin.String, counter: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<Operation> {
        val localVarResponse = operationsGetByHashCounterWithHttpInfo(hash = hash, counter = counter, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Operation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get operations by hash and counter
    * Returns a list of operations with the specified hash and counter.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<Operation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetByHashCounterWithHttpInfo(hash: kotlin.String, counter: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<Operation>?> {
        val localVariableConfig = operationsGetByHashCounterRequestConfig(hash = hash, counter = counter, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<Operation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetByHashCounter
    *
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetByHashCounterRequestConfig(hash: kotlin.String, counter: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/{hash}/{counter}".replace("{"+"hash"+"}", "$hash").replace("{"+"counter"+"}", "$counter"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get operations by hash, counter and nonce
    * Returns an internal operations with the specified hash, counter and nonce.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param nonce Operation nonce (internal) 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<Operation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetByHashCounterNonce(hash: kotlin.String, counter: kotlin.Int, nonce: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<Operation> {
        val localVarResponse = operationsGetByHashCounterNonceWithHttpInfo(hash = hash, counter = counter, nonce = nonce, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Operation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get operations by hash, counter and nonce
    * Returns an internal operations with the specified hash, counter and nonce.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param nonce Operation nonce (internal) 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<Operation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetByHashCounterNonceWithHttpInfo(hash: kotlin.String, counter: kotlin.Int, nonce: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<Operation>?> {
        val localVariableConfig = operationsGetByHashCounterNonceRequestConfig(hash = hash, counter = counter, nonce = nonce, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<Operation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetByHashCounterNonce
    *
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param nonce Operation nonce (internal) 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetByHashCounterNonceRequestConfig(hash: kotlin.String, counter: kotlin.Int, nonce: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/{hash}/{counter}/{nonce}".replace("{"+"hash"+"}", "$hash").replace("{"+"counter"+"}", "$counter").replace("{"+"nonce"+"}", "$nonce"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get delegation by hash
    * Returns a delegation operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<DelegationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDelegationByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<DelegationOperation> {
        val localVarResponse = operationsGetDelegationByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DelegationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get delegation by hash
    * Returns a delegation operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<DelegationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDelegationByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<DelegationOperation>?> {
        val localVariableConfig = operationsGetDelegationByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<DelegationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDelegationByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetDelegationByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/delegations/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get delegations
    * Returns a list of delegation operations.
    * @param anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
    * @param initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param prevDelegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param newDelegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
    * @param level Filters delegations by level. (optional)
    * @param timestamp Filters delegations by timestamp. (optional)
    * @param status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<DelegationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDelegations(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, prevDelegate: AccountParameter?, newDelegate: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<DelegationOperation> {
        val localVarResponse = operationsGetDelegationsWithHttpInfo(anyof = anyof, initiator = initiator, sender = sender, prevDelegate = prevDelegate, newDelegate = newDelegate, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DelegationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get delegations
    * Returns a list of delegation operations.
    * @param anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
    * @param initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param prevDelegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param newDelegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
    * @param level Filters delegations by level. (optional)
    * @param timestamp Filters delegations by timestamp. (optional)
    * @param status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<DelegationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDelegationsWithHttpInfo(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, prevDelegate: AccountParameter?, newDelegate: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<DelegationOperation>?> {
        val localVariableConfig = operationsGetDelegationsRequestConfig(anyof = anyof, initiator = initiator, sender = sender, prevDelegate = prevDelegate, newDelegate = newDelegate, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<DelegationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDelegations
    *
    * @param anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
    * @param initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param prevDelegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
    * @param newDelegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
    * @param level Filters delegations by level. (optional)
    * @param timestamp Filters delegations by timestamp. (optional)
    * @param status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetDelegationsRequestConfig(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, prevDelegate: AccountParameter?, newDelegate: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (initiator != null) {
                    put("initiator", listOf(initiator.toString()))
                }
                if (sender != null) {
                    put("sender", listOf(sender.toString()))
                }
                if (prevDelegate != null) {
                    put("prevDelegate", listOf(prevDelegate.toString()))
                }
                if (newDelegate != null) {
                    put("newDelegate", listOf(newDelegate.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get delegations count
    * Returns the total number of delegation operations.
    * @param level Filters delegations by level. (optional)
    * @param timestamp Filters delegations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDelegationsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetDelegationsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get delegations count
    * Returns the total number of delegation operations.
    * @param level Filters delegations by level. (optional)
    * @param timestamp Filters delegations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDelegationsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetDelegationsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDelegationsCount
    *
    * @param level Filters delegations by level. (optional)
    * @param timestamp Filters delegations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetDelegationsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/delegations/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get double baking
    * Returns a list of double baking operations.
    * @param anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
    * @param offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
    * @param level Filters double baking operations by level. (optional)
    * @param timestamp Filters double baking operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<DoubleBakingOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDoubleBaking(anyof: kotlin.String?, accuser: AccountParameter?, offender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<DoubleBakingOperation> {
        val localVarResponse = operationsGetDoubleBakingWithHttpInfo(anyof = anyof, accuser = accuser, offender = offender, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DoubleBakingOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get double baking
    * Returns a list of double baking operations.
    * @param anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
    * @param offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
    * @param level Filters double baking operations by level. (optional)
    * @param timestamp Filters double baking operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<DoubleBakingOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDoubleBakingWithHttpInfo(anyof: kotlin.String?, accuser: AccountParameter?, offender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<DoubleBakingOperation>?> {
        val localVariableConfig = operationsGetDoubleBakingRequestConfig(anyof = anyof, accuser = accuser, offender = offender, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<DoubleBakingOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDoubleBaking
    *
    * @param anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
    * @param offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
    * @param level Filters double baking operations by level. (optional)
    * @param timestamp Filters double baking operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetDoubleBakingRequestConfig(anyof: kotlin.String?, accuser: AccountParameter?, offender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (accuser != null) {
                    put("accuser", listOf(accuser.toString()))
                }
                if (offender != null) {
                    put("offender", listOf(offender.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/double_baking",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get double baking by hash
    * Returns a double baking operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<DoubleBakingOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDoubleBakingByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<DoubleBakingOperation> {
        val localVarResponse = operationsGetDoubleBakingByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DoubleBakingOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get double baking by hash
    * Returns a double baking operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<DoubleBakingOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDoubleBakingByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<DoubleBakingOperation>?> {
        val localVariableConfig = operationsGetDoubleBakingByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<DoubleBakingOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDoubleBakingByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetDoubleBakingByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/double_baking/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get double baking count
    * Returns the total number of double baking operations.
    * @param level Filters double baking operations by level. (optional)
    * @param timestamp Filters double baking operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDoubleBakingCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetDoubleBakingCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get double baking count
    * Returns the total number of double baking operations.
    * @param level Filters double baking operations by level. (optional)
    * @param timestamp Filters double baking operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDoubleBakingCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetDoubleBakingCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDoubleBakingCount
    *
    * @param level Filters double baking operations by level. (optional)
    * @param timestamp Filters double baking operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetDoubleBakingCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/double_baking/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get double endorsing
    * Returns a list of double endorsing operations.
    * @param anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
    * @param offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
    * @param level Filters double endorsing operations by level. (optional)
    * @param timestamp Filters double endorsing operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<DoubleEndorsingOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDoubleEndorsing(anyof: kotlin.String?, accuser: AccountParameter?, offender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<DoubleEndorsingOperation> {
        val localVarResponse = operationsGetDoubleEndorsingWithHttpInfo(anyof = anyof, accuser = accuser, offender = offender, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DoubleEndorsingOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get double endorsing
    * Returns a list of double endorsing operations.
    * @param anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
    * @param offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
    * @param level Filters double endorsing operations by level. (optional)
    * @param timestamp Filters double endorsing operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<DoubleEndorsingOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDoubleEndorsingWithHttpInfo(anyof: kotlin.String?, accuser: AccountParameter?, offender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<DoubleEndorsingOperation>?> {
        val localVariableConfig = operationsGetDoubleEndorsingRequestConfig(anyof = anyof, accuser = accuser, offender = offender, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<DoubleEndorsingOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDoubleEndorsing
    *
    * @param anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
    * @param offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
    * @param level Filters double endorsing operations by level. (optional)
    * @param timestamp Filters double endorsing operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetDoubleEndorsingRequestConfig(anyof: kotlin.String?, accuser: AccountParameter?, offender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (accuser != null) {
                    put("accuser", listOf(accuser.toString()))
                }
                if (offender != null) {
                    put("offender", listOf(offender.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/double_endorsing",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get double endorsing by hash
    * Returns a double endorsing operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<DoubleEndorsingOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDoubleEndorsingByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<DoubleEndorsingOperation> {
        val localVarResponse = operationsGetDoubleEndorsingByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DoubleEndorsingOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get double endorsing by hash
    * Returns a double endorsing operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<DoubleEndorsingOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDoubleEndorsingByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<DoubleEndorsingOperation>?> {
        val localVariableConfig = operationsGetDoubleEndorsingByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<DoubleEndorsingOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDoubleEndorsingByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetDoubleEndorsingByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/double_endorsing/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get double endorsing count
    * Returns the total number of double endorsing operations.
    * @param level Filters double endorsing operations by level. (optional)
    * @param timestamp Filters double endorsing operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetDoubleEndorsingCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetDoubleEndorsingCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get double endorsing count
    * Returns the total number of double endorsing operations.
    * @param level Filters double endorsing operations by level. (optional)
    * @param timestamp Filters double endorsing operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetDoubleEndorsingCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetDoubleEndorsingCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetDoubleEndorsingCount
    *
    * @param level Filters double endorsing operations by level. (optional)
    * @param timestamp Filters double endorsing operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetDoubleEndorsingCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/double_endorsing/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get endorsement by hash
    * Returns an endorsement operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<EndorsementOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetEndorsementByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<EndorsementOperation> {
        val localVarResponse = operationsGetEndorsementByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EndorsementOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get endorsement by hash
    * Returns an endorsement operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<EndorsementOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetEndorsementByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<EndorsementOperation>?> {
        val localVariableConfig = operationsGetEndorsementByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<EndorsementOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetEndorsementByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetEndorsementByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/endorsements/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get endorsements
    * Returns a list of endorsement operations.
    * @param `delegate` Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters endorsements by level. (optional)
    * @param timestamp Filters endorsements by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<EndorsementOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetEndorsements(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<EndorsementOperation> {
        val localVarResponse = operationsGetEndorsementsWithHttpInfo(`delegate` = `delegate`, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EndorsementOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get endorsements
    * Returns a list of endorsement operations.
    * @param `delegate` Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters endorsements by level. (optional)
    * @param timestamp Filters endorsements by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<EndorsementOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetEndorsementsWithHttpInfo(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<EndorsementOperation>?> {
        val localVariableConfig = operationsGetEndorsementsRequestConfig(`delegate` = `delegate`, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<EndorsementOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetEndorsements
    *
    * @param `delegate` Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters endorsements by level. (optional)
    * @param timestamp Filters endorsements by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetEndorsementsRequestConfig(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (`delegate` != null) {
                    put("delegate", listOf(`delegate`.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/endorsements",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get endorsements count
    * Returns the total number of endorsement operations.
    * @param level Filters endorsements by level. (optional)
    * @param timestamp Filters endorsements by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetEndorsementsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetEndorsementsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get endorsements count
    * Returns the total number of endorsement operations.
    * @param level Filters endorsements by level. (optional)
    * @param timestamp Filters endorsements by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetEndorsementsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetEndorsementsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetEndorsementsCount
    *
    * @param level Filters endorsements by level. (optional)
    * @param timestamp Filters endorsements by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetEndorsementsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/endorsements/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get migration by id
    * Returns migration operation with specified id.
    * @param id Operation id 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return MigrationOperation
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetMigrationById(id: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : MigrationOperation {
        val localVarResponse = operationsGetMigrationByIdWithHttpInfo(id = id, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MigrationOperation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get migration by id
    * Returns migration operation with specified id.
    * @param id Operation id 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<MigrationOperation?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetMigrationByIdWithHttpInfo(id: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<MigrationOperation?> {
        val localVariableConfig = operationsGetMigrationByIdRequestConfig(id = id, micheline = micheline, quote = quote)

        return request<Unit, MigrationOperation>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetMigrationById
    *
    * @param id Operation id 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetMigrationByIdRequestConfig(id: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/migrations/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get migrations
    * Returns a list of migration operations (synthetic type).
    * @param account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;). (optional)
    * @param balanceChange Filters migration operations by amount. (optional)
    * @param id Filters migration operations by internal TzKT id. (optional)
    * @param level Filters migration operations by level. (optional)
    * @param timestamp Filters migration operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<MigrationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetMigrations(account: AccountParameter?, kind: MigrationKindParameter?, balanceChange: IntParameter?, id: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<MigrationOperation> {
        val localVarResponse = operationsGetMigrationsWithHttpInfo(account = account, kind = kind, balanceChange = balanceChange, id = id, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MigrationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get migrations
    * Returns a list of migration operations (synthetic type).
    * @param account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;). (optional)
    * @param balanceChange Filters migration operations by amount. (optional)
    * @param id Filters migration operations by internal TzKT id. (optional)
    * @param level Filters migration operations by level. (optional)
    * @param timestamp Filters migration operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<MigrationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetMigrationsWithHttpInfo(account: AccountParameter?, kind: MigrationKindParameter?, balanceChange: IntParameter?, id: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<MigrationOperation>?> {
        val localVariableConfig = operationsGetMigrationsRequestConfig(account = account, kind = kind, balanceChange = balanceChange, id = id, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<MigrationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetMigrations
    *
    * @param account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;). (optional)
    * @param balanceChange Filters migration operations by amount. (optional)
    * @param id Filters migration operations by internal TzKT id. (optional)
    * @param level Filters migration operations by level. (optional)
    * @param timestamp Filters migration operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetMigrationsRequestConfig(account: AccountParameter?, kind: MigrationKindParameter?, balanceChange: IntParameter?, id: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (account != null) {
                    put("account", listOf(account.toString()))
                }
                if (kind != null) {
                    put("kind", listOf(kind.toString()))
                }
                if (balanceChange != null) {
                    put("balanceChange", listOf(balanceChange.toString()))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/migrations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get migrations count
    * Returns the total number of migration operations (synthetic type).
    * @param level Filters migrations by level. (optional)
    * @param timestamp Filters migrations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetMigrationsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetMigrationsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get migrations count
    * Returns the total number of migration operations (synthetic type).
    * @param level Filters migrations by level. (optional)
    * @param timestamp Filters migrations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetMigrationsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetMigrationsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetMigrationsCount
    *
    * @param level Filters migrations by level. (optional)
    * @param timestamp Filters migrations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetMigrationsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/migrations/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get nonce revelation by hash
    * Returns a seed nonce revelation operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<NonceRevelationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetNonceRevelationByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<NonceRevelationOperation> {
        val localVarResponse = operationsGetNonceRevelationByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<NonceRevelationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get nonce revelation by hash
    * Returns a seed nonce revelation operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<NonceRevelationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetNonceRevelationByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<NonceRevelationOperation>?> {
        val localVariableConfig = operationsGetNonceRevelationByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<NonceRevelationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetNonceRevelationByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetNonceRevelationByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/nonce_revelations/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get nonce revelations
    * Returns a list of seed nonce revelation operations.
    * @param anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
    * @param sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
    * @param level Filters nonce revelation operations by level. (optional)
    * @param timestamp Filters nonce revelation operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<NonceRevelationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetNonceRevelations(anyof: kotlin.String?, baker: AccountParameter?, sender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<NonceRevelationOperation> {
        val localVarResponse = operationsGetNonceRevelationsWithHttpInfo(anyof = anyof, baker = baker, sender = sender, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<NonceRevelationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get nonce revelations
    * Returns a list of seed nonce revelation operations.
    * @param anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
    * @param sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
    * @param level Filters nonce revelation operations by level. (optional)
    * @param timestamp Filters nonce revelation operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<NonceRevelationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetNonceRevelationsWithHttpInfo(anyof: kotlin.String?, baker: AccountParameter?, sender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<NonceRevelationOperation>?> {
        val localVariableConfig = operationsGetNonceRevelationsRequestConfig(anyof = anyof, baker = baker, sender = sender, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<NonceRevelationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetNonceRevelations
    *
    * @param anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
    * @param baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
    * @param sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
    * @param level Filters nonce revelation operations by level. (optional)
    * @param timestamp Filters nonce revelation operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetNonceRevelationsRequestConfig(anyof: kotlin.String?, baker: AccountParameter?, sender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (baker != null) {
                    put("baker", listOf(baker.toString()))
                }
                if (sender != null) {
                    put("sender", listOf(sender.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/nonce_revelations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get nonce revelations count
    * Returns the total number of seed nonce revelation operations.
    * @param level Filters seed nonce revelation operations by level. (optional)
    * @param timestamp Filters seed nonce revelation operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetNonceRevelationsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetNonceRevelationsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get nonce revelations count
    * Returns the total number of seed nonce revelation operations.
    * @param level Filters seed nonce revelation operations by level. (optional)
    * @param timestamp Filters seed nonce revelation operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetNonceRevelationsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetNonceRevelationsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetNonceRevelationsCount
    *
    * @param level Filters seed nonce revelation operations by level. (optional)
    * @param timestamp Filters seed nonce revelation operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetNonceRevelationsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/nonce_revelations/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get origination by hash
    * Returns origination operations with specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<OriginationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetOriginationByHash(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<OriginationOperation> {
        val localVarResponse = operationsGetOriginationByHashWithHttpInfo(hash = hash, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OriginationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get origination by hash
    * Returns origination operations with specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<OriginationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetOriginationByHashWithHttpInfo(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<OriginationOperation>?> {
        val localVariableConfig = operationsGetOriginationByHashRequestConfig(hash = hash, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<OriginationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetOriginationByHash
    *
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetOriginationByHashRequestConfig(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/originations/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get originations
    * Returns a list of origination operations.
    * @param anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
    * @param initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param contractManager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param contractDelegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
    * @param originatedContract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param id Filters origination operations by internal TzKT id (optional)
    * @param typeHash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
    * @param codeHash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
    * @param level Filters origination operations by level. (optional)
    * @param timestamp Filters origination operations by timestamp. (optional)
    * @param status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<OriginationOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetOriginations(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, contractManager: AccountParameter?, contractDelegate: AccountParameter?, originatedContract: AccountParameter?, id: IntParameter?, typeHash: IntParameter?, codeHash: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<OriginationOperation> {
        val localVarResponse = operationsGetOriginationsWithHttpInfo(anyof = anyof, initiator = initiator, sender = sender, contractManager = contractManager, contractDelegate = contractDelegate, originatedContract = originatedContract, id = id, typeHash = typeHash, codeHash = codeHash, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OriginationOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get originations
    * Returns a list of origination operations.
    * @param anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
    * @param initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param contractManager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param contractDelegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
    * @param originatedContract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param id Filters origination operations by internal TzKT id (optional)
    * @param typeHash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
    * @param codeHash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
    * @param level Filters origination operations by level. (optional)
    * @param timestamp Filters origination operations by timestamp. (optional)
    * @param status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<OriginationOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetOriginationsWithHttpInfo(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, contractManager: AccountParameter?, contractDelegate: AccountParameter?, originatedContract: AccountParameter?, id: IntParameter?, typeHash: IntParameter?, codeHash: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<OriginationOperation>?> {
        val localVariableConfig = operationsGetOriginationsRequestConfig(anyof = anyof, initiator = initiator, sender = sender, contractManager = contractManager, contractDelegate = contractDelegate, originatedContract = originatedContract, id = id, typeHash = typeHash, codeHash = codeHash, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<OriginationOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetOriginations
    *
    * @param anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
    * @param initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param contractManager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
    * @param contractDelegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
    * @param originatedContract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param id Filters origination operations by internal TzKT id (optional)
    * @param typeHash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
    * @param codeHash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
    * @param level Filters origination operations by level. (optional)
    * @param timestamp Filters origination operations by timestamp. (optional)
    * @param status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetOriginationsRequestConfig(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, contractManager: AccountParameter?, contractDelegate: AccountParameter?, originatedContract: AccountParameter?, id: IntParameter?, typeHash: IntParameter?, codeHash: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (initiator != null) {
                    put("initiator", listOf(initiator.toString()))
                }
                if (sender != null) {
                    put("sender", listOf(sender.toString()))
                }
                if (contractManager != null) {
                    put("contractManager", listOf(contractManager.toString()))
                }
                if (contractDelegate != null) {
                    put("contractDelegate", listOf(contractDelegate.toString()))
                }
                if (originatedContract != null) {
                    put("originatedContract", listOf(originatedContract.toString()))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (typeHash != null) {
                    put("typeHash", listOf(typeHash.toString()))
                }
                if (codeHash != null) {
                    put("codeHash", listOf(codeHash.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/originations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get originations count
    * Returns the total number of origination operations.
    * @param level Filters originations by level. (optional)
    * @param timestamp Filters originations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetOriginationsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetOriginationsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get originations count
    * Returns the total number of origination operations.
    * @param level Filters originations by level. (optional)
    * @param timestamp Filters originations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetOriginationsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetOriginationsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetOriginationsCount
    *
    * @param level Filters originations by level. (optional)
    * @param timestamp Filters originations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetOriginationsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/originations/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get proposal by hash
    * Returns a proposal operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<ProposalOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetProposalByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<ProposalOperation> {
        val localVarResponse = operationsGetProposalByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProposalOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get proposal by hash
    * Returns a proposal operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<ProposalOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetProposalByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<ProposalOperation>?> {
        val localVariableConfig = operationsGetProposalByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<ProposalOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetProposalByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetProposalByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/proposals/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get proposals
    * Returns a list of proposal operations.
    * @param `delegate` Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters proposal operations by level. (optional)
    * @param timestamp Filters proposal operations by timestamp. (optional)
    * @param epoch Filters proposal operations by voting epoch. (optional)
    * @param period Filters proposal operations by voting period. (optional)
    * @param proposal Filters proposal operations by proposal hash. (optional)
    * @param duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<ProposalOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetProposals(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, epoch: IntParameter?, period: IntParameter?, proposal: ProtocolParameter?, duplicated: BoolParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<ProposalOperation> {
        val localVarResponse = operationsGetProposalsWithHttpInfo(`delegate` = `delegate`, level = level, timestamp = timestamp, epoch = epoch, period = period, proposal = proposal, duplicated = duplicated, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProposalOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get proposals
    * Returns a list of proposal operations.
    * @param `delegate` Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters proposal operations by level. (optional)
    * @param timestamp Filters proposal operations by timestamp. (optional)
    * @param epoch Filters proposal operations by voting epoch. (optional)
    * @param period Filters proposal operations by voting period. (optional)
    * @param proposal Filters proposal operations by proposal hash. (optional)
    * @param duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<ProposalOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetProposalsWithHttpInfo(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, epoch: IntParameter?, period: IntParameter?, proposal: ProtocolParameter?, duplicated: BoolParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<ProposalOperation>?> {
        val localVariableConfig = operationsGetProposalsRequestConfig(`delegate` = `delegate`, level = level, timestamp = timestamp, epoch = epoch, period = period, proposal = proposal, duplicated = duplicated, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<ProposalOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetProposals
    *
    * @param `delegate` Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters proposal operations by level. (optional)
    * @param timestamp Filters proposal operations by timestamp. (optional)
    * @param epoch Filters proposal operations by voting epoch. (optional)
    * @param period Filters proposal operations by voting period. (optional)
    * @param proposal Filters proposal operations by proposal hash. (optional)
    * @param duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetProposalsRequestConfig(`delegate`: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, epoch: IntParameter?, period: IntParameter?, proposal: ProtocolParameter?, duplicated: BoolParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (`delegate` != null) {
                    put("delegate", listOf(`delegate`.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (epoch != null) {
                    put("epoch", listOf(epoch.toString()))
                }
                if (period != null) {
                    put("period", listOf(period.toString()))
                }
                if (proposal != null) {
                    put("proposal", listOf(proposal.toString()))
                }
                if (duplicated != null) {
                    put("duplicated", listOf(duplicated.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/proposals",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get proposals count
    * Returns the total number of proposal operations.
    * @param level Filters proposal operations by level. (optional)
    * @param timestamp Filters proposal operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetProposalsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetProposalsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get proposals count
    * Returns the total number of proposal operations.
    * @param level Filters proposal operations by level. (optional)
    * @param timestamp Filters proposal operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetProposalsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetProposalsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetProposalsCount
    *
    * @param level Filters proposal operations by level. (optional)
    * @param timestamp Filters proposal operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetProposalsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/proposals/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get register constant by hash
    * Returns register global constant operation with specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<RegisterConstantOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRegisterConstantByHash(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<RegisterConstantOperation> {
        val localVarResponse = operationsGetRegisterConstantByHashWithHttpInfo(hash = hash, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RegisterConstantOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get register constant by hash
    * Returns register global constant operation with specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<RegisterConstantOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRegisterConstantByHashWithHttpInfo(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<RegisterConstantOperation>?> {
        val localVariableConfig = operationsGetRegisterConstantByHashRequestConfig(hash = hash, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<RegisterConstantOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRegisterConstantByHash
    *
    * @param hash Operation hash 
    * @param micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetRegisterConstantByHashRequestConfig(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/register_constants/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get register constants
    * Returns a list of register global constant operations.
    * @param sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
    * @param level Filters operations by level. (optional)
    * @param timestamp Filters operations by timestamp. (optional)
    * @param status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<RegisterConstantOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRegisterConstants(sender: AccountParameter?, address: ExpressionParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<RegisterConstantOperation> {
        val localVarResponse = operationsGetRegisterConstantsWithHttpInfo(sender = sender, address = address, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RegisterConstantOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get register constants
    * Returns a list of register global constant operations.
    * @param sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
    * @param level Filters operations by level. (optional)
    * @param timestamp Filters operations by timestamp. (optional)
    * @param status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<RegisterConstantOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRegisterConstantsWithHttpInfo(sender: AccountParameter?, address: ExpressionParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<RegisterConstantOperation>?> {
        val localVariableConfig = operationsGetRegisterConstantsRequestConfig(sender = sender, address = address, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<RegisterConstantOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRegisterConstants
    *
    * @param sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
    * @param level Filters operations by level. (optional)
    * @param timestamp Filters operations by timestamp. (optional)
    * @param status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetRegisterConstantsRequestConfig(sender: AccountParameter?, address: ExpressionParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sender != null) {
                    put("sender", listOf(sender.toString()))
                }
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/register_constants",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get register constants count
    * Returns the total number of register global constant operations.
    * @param level Filters operations by level. (optional)
    * @param timestamp Filters operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRegisterConstantsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetRegisterConstantsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get register constants count
    * Returns the total number of register global constant operations.
    * @param level Filters operations by level. (optional)
    * @param timestamp Filters operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRegisterConstantsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetRegisterConstantsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRegisterConstantsCount
    *
    * @param level Filters operations by level. (optional)
    * @param timestamp Filters operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetRegisterConstantsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/register_constants/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get reveal by hash
    * Returns reveal operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<RevealOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRevealByHash(hash: kotlin.String, quote: Symbols?) : kotlin.collections.List<RevealOperation> {
        val localVarResponse = operationsGetRevealByHashWithHttpInfo(hash = hash, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RevealOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get reveal by hash
    * Returns reveal operation with specified hash.
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<RevealOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRevealByHashWithHttpInfo(hash: kotlin.String, quote: Symbols?) : ApiResponse<kotlin.collections.List<RevealOperation>?> {
        val localVariableConfig = operationsGetRevealByHashRequestConfig(hash = hash, quote = quote)

        return request<Unit, kotlin.collections.List<RevealOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRevealByHash
    *
    * @param hash Operation hash 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetRevealByHashRequestConfig(hash: kotlin.String, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/reveals/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get reveals
    * Returns a list of reveal operations.
    * @param sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters reveal operations by level. (optional)
    * @param timestamp Filters reveal operations by timestamp. (optional)
    * @param status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<RevealOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetReveals(sender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<RevealOperation> {
        val localVarResponse = operationsGetRevealsWithHttpInfo(sender = sender, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RevealOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get reveals
    * Returns a list of reveal operations.
    * @param sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters reveal operations by level. (optional)
    * @param timestamp Filters reveal operations by timestamp. (optional)
    * @param status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<RevealOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRevealsWithHttpInfo(sender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<RevealOperation>?> {
        val localVariableConfig = operationsGetRevealsRequestConfig(sender = sender, level = level, timestamp = timestamp, status = status, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<RevealOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetReveals
    *
    * @param sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters reveal operations by level. (optional)
    * @param timestamp Filters reveal operations by timestamp. (optional)
    * @param status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetRevealsRequestConfig(sender: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sender != null) {
                    put("sender", listOf(sender.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/reveals",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get reveals count
    * Returns the total number of reveal operations.
    * @param level Filters reveals by level. (optional)
    * @param timestamp Filters reveals by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRevealsCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetRevealsCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get reveals count
    * Returns the total number of reveal operations.
    * @param level Filters reveals by level. (optional)
    * @param timestamp Filters reveals by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRevealsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetRevealsCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRevealsCount
    *
    * @param level Filters reveals by level. (optional)
    * @param timestamp Filters reveals by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetRevealsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/reveals/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get revelation penalties
    * Returns a list of revelation penalty operations (synthetic type).
    * @param baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters revelation penalty operations by level. (optional)
    * @param timestamp Filters revelation penalty operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<RevelationPenaltyOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRevelationPenalties(baker: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : kotlin.collections.List<RevelationPenaltyOperation> {
        val localVarResponse = operationsGetRevelationPenaltiesWithHttpInfo(baker = baker, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RevelationPenaltyOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get revelation penalties
    * Returns a list of revelation penalty operations (synthetic type).
    * @param baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters revelation penalty operations by level. (optional)
    * @param timestamp Filters revelation penalty operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<RevelationPenaltyOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRevelationPenaltiesWithHttpInfo(baker: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : ApiResponse<kotlin.collections.List<RevelationPenaltyOperation>?> {
        val localVariableConfig = operationsGetRevelationPenaltiesRequestConfig(baker = baker, level = level, timestamp = timestamp, select = select, sort = sort, offset = offset, limit = limit, quote = quote)

        return request<Unit, kotlin.collections.List<RevelationPenaltyOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRevelationPenalties
    *
    * @param baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
    * @param level Filters revelation penalty operations by level. (optional)
    * @param timestamp Filters revelation penalty operations by timestamp. (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetRevelationPenaltiesRequestConfig(baker: AccountParameter?, level: IntParameter?, timestamp: DateTimeParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (baker != null) {
                    put("baker", listOf(baker.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/revelation_penalties",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get revelation penalties count
    * Returns the total number of revelation penalty operations (synthetic type).
    * @param level Filters revelation penalty operations by level. (optional)
    * @param timestamp Filters revelation penalty operations by timestamp. (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRevelationPenaltiesCount(level: IntParameter?, timestamp: DateTimeParameter?) : kotlin.Int {
        val localVarResponse = operationsGetRevelationPenaltiesCountWithHttpInfo(level = level, timestamp = timestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get revelation penalties count
    * Returns the total number of revelation penalty operations (synthetic type).
    * @param level Filters revelation penalty operations by level. (optional)
    * @param timestamp Filters revelation penalty operations by timestamp. (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRevelationPenaltiesCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetRevelationPenaltiesCountRequestConfig(level = level, timestamp = timestamp)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRevelationPenaltiesCount
    *
    * @param level Filters revelation penalty operations by level. (optional)
    * @param timestamp Filters revelation penalty operations by timestamp. (optional)
    * @return RequestConfig
    */
    fun operationsGetRevelationPenaltiesCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/revelation_penalties/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get revelation penalty by id
    * Returns revelation penalty operation with specified id.
    * @param id Operation id 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RevelationPenaltyOperation
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetRevelationPenaltyById(id: kotlin.Int, quote: Symbols?) : RevelationPenaltyOperation {
        val localVarResponse = operationsGetRevelationPenaltyByIdWithHttpInfo(id = id, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RevelationPenaltyOperation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get revelation penalty by id
    * Returns revelation penalty operation with specified id.
    * @param id Operation id 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<RevelationPenaltyOperation?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetRevelationPenaltyByIdWithHttpInfo(id: kotlin.Int, quote: Symbols?) : ApiResponse<RevelationPenaltyOperation?> {
        val localVariableConfig = operationsGetRevelationPenaltyByIdRequestConfig(id = id, quote = quote)

        return request<Unit, RevelationPenaltyOperation>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetRevelationPenaltyById
    *
    * @param id Operation id 
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetRevelationPenaltyByIdRequestConfig(id: kotlin.Int, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/revelation_penalties/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get transaction by hash
    * Returns transaction operations with specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<TransactionOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetTransactionByHash(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<TransactionOperation> {
        val localVarResponse = operationsGetTransactionByHashWithHttpInfo(hash = hash, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TransactionOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get transaction by hash
    * Returns transaction operations with specified hash.
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<TransactionOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetTransactionByHashWithHttpInfo(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<TransactionOperation>?> {
        val localVariableConfig = operationsGetTransactionByHashRequestConfig(hash = hash, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<TransactionOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetTransactionByHash
    *
    * @param hash Operation hash 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetTransactionByHashRequestConfig(hash: kotlin.String, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/transactions/{hash}".replace("{"+"hash"+"}", "$hash"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get transaction by hash and counter
    * Returns transaction operations with specified hash and counter.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<TransactionOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetTransactionByHashCounter(hash: kotlin.String, counter: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<TransactionOperation> {
        val localVarResponse = operationsGetTransactionByHashCounterWithHttpInfo(hash = hash, counter = counter, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TransactionOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get transaction by hash and counter
    * Returns transaction operations with specified hash and counter.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<TransactionOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetTransactionByHashCounterWithHttpInfo(hash: kotlin.String, counter: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<TransactionOperation>?> {
        val localVariableConfig = operationsGetTransactionByHashCounterRequestConfig(hash = hash, counter = counter, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<TransactionOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetTransactionByHashCounter
    *
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetTransactionByHashCounterRequestConfig(hash: kotlin.String, counter: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/transactions/{hash}/{counter}".replace("{"+"hash"+"}", "$hash").replace("{"+"counter"+"}", "$counter"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get transaction by hash, counter and nonce
    * Returns an internal transaction operation with specified hash, counter and nonce.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param nonce Operation nonce (internal) 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<TransactionOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetTransactionByHashCounterNonce(hash: kotlin.String, counter: kotlin.Int, nonce: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<TransactionOperation> {
        val localVarResponse = operationsGetTransactionByHashCounterNonceWithHttpInfo(hash = hash, counter = counter, nonce = nonce, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TransactionOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get transaction by hash, counter and nonce
    * Returns an internal transaction operation with specified hash, counter and nonce.
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param nonce Operation nonce (internal) 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<TransactionOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetTransactionByHashCounterNonceWithHttpInfo(hash: kotlin.String, counter: kotlin.Int, nonce: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<TransactionOperation>?> {
        val localVariableConfig = operationsGetTransactionByHashCounterNonceRequestConfig(hash = hash, counter = counter, nonce = nonce, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<TransactionOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetTransactionByHashCounterNonce
    *
    * @param hash Operation hash 
    * @param counter Operation counter 
    * @param nonce Operation nonce (internal) 
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetTransactionByHashCounterNonceRequestConfig(hash: kotlin.String, counter: kotlin.Int, nonce: kotlin.Int, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/transactions/{hash}/{counter}/{nonce}".replace("{"+"hash"+"}", "$hash").replace("{"+"counter"+"}", "$counter").replace("{"+"nonce"+"}", "$nonce"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get transactions
    * Returns a list of transaction operations.
    * @param anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
    * @param initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
    * @param sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
    * @param target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
    * @param amount Filters transactions by amount (microtez). (optional)
    * @param id Filters transactions by id. (optional)
    * @param level Filters transactions by level. (optional)
    * @param timestamp Filters transactions by timestamp. (optional)
    * @param entrypoint Filters transactions by entrypoint called on the target contract. (optional)
    * @param parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
    * @param hasInternals Filters transactions by presence of internal operations. (optional)
    * @param status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return kotlin.collections.List<TransactionOperation>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetTransactions(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, target: AccountParameter?, amount: IntParameter?, id: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, entrypoint: StringParameter?, parameter: JsonParameter?, hasInternals: BoolParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : kotlin.collections.List<TransactionOperation> {
        val localVarResponse = operationsGetTransactionsWithHttpInfo(anyof = anyof, initiator = initiator, sender = sender, target = target, amount = amount, id = id, level = level, timestamp = timestamp, entrypoint = entrypoint, parameter = parameter, hasInternals = hasInternals, status = status, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TransactionOperation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get transactions
    * Returns a list of transaction operations.
    * @param anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
    * @param initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
    * @param sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
    * @param target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
    * @param amount Filters transactions by amount (microtez). (optional)
    * @param id Filters transactions by id. (optional)
    * @param level Filters transactions by level. (optional)
    * @param timestamp Filters transactions by timestamp. (optional)
    * @param entrypoint Filters transactions by entrypoint called on the target contract. (optional)
    * @param parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
    * @param hasInternals Filters transactions by presence of internal operations. (optional)
    * @param status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return ApiResponse<kotlin.collections.List<TransactionOperation>?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetTransactionsWithHttpInfo(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, target: AccountParameter?, amount: IntParameter?, id: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, entrypoint: StringParameter?, parameter: JsonParameter?, hasInternals: BoolParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : ApiResponse<kotlin.collections.List<TransactionOperation>?> {
        val localVariableConfig = operationsGetTransactionsRequestConfig(anyof = anyof, initiator = initiator, sender = sender, target = target, amount = amount, id = id, level = level, timestamp = timestamp, entrypoint = entrypoint, parameter = parameter, hasInternals = hasInternals, status = status, select = select, sort = sort, offset = offset, limit = limit, micheline = micheline, quote = quote)

        return request<Unit, kotlin.collections.List<TransactionOperation>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetTransactions
    *
    * @param anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
    * @param initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
    * @param sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
    * @param target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
    * @param amount Filters transactions by amount (microtez). (optional)
    * @param id Filters transactions by id. (optional)
    * @param level Filters transactions by level. (optional)
    * @param timestamp Filters transactions by timestamp. (optional)
    * @param entrypoint Filters transactions by entrypoint called on the target contract. (optional)
    * @param parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
    * @param hasInternals Filters transactions by presence of internal operations. (optional)
    * @param status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @param select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
    * @param sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
    * @param offset Specifies which or how many items should be skipped (optional)
    * @param limit Maximum number of items to return (optional, default to 100)
    * @param micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
    * @param quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
    * @return RequestConfig
    */
    fun operationsGetTransactionsRequestConfig(anyof: kotlin.String?, initiator: AccountParameter?, sender: AccountParameter?, target: AccountParameter?, amount: IntParameter?, id: IntParameter?, level: IntParameter?, timestamp: DateTimeParameter?, entrypoint: StringParameter?, parameter: JsonParameter?, hasInternals: BoolParameter?, status: OperationStatusParameter?, select: SelectParameter?, sort: SortParameter?, offset: OffsetParameter?, limit: kotlin.Int?, micheline: MichelineFormat?, quote: Symbols?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (anyof != null) {
                    put("anyof", listOf(anyof.toString()))
                }
                if (initiator != null) {
                    put("initiator", listOf(initiator.toString()))
                }
                if (sender != null) {
                    put("sender", listOf(sender.toString()))
                }
                if (target != null) {
                    put("target", listOf(target.toString()))
                }
                if (amount != null) {
                    put("amount", listOf(amount.toString()))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (entrypoint != null) {
                    put("entrypoint", listOf(entrypoint.toString()))
                }
                if (parameter != null) {
                    put("parameter", listOf(parameter.toString()))
                }
                if (hasInternals != null) {
                    put("hasInternals", listOf(hasInternals.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (select != null) {
                    put("select", listOf(select.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (micheline != null) {
                    put("micheline", listOf(micheline.toString()))
                }
                if (quote != null) {
                    put("quote", listOf(quote.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get transactions count
    * Returns the total number of transaction operations.
    * @param level Filters transactions by level. (optional)
    * @param timestamp Filters transactions by timestamp. (optional)
    * @param status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @return kotlin.Int
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun operationsGetTransactionsCount(level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?) : kotlin.Int {
        val localVarResponse = operationsGetTransactionsCountWithHttpInfo(level = level, timestamp = timestamp, status = status)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get transactions count
    * Returns the total number of transaction operations.
    * @param level Filters transactions by level. (optional)
    * @param timestamp Filters transactions by timestamp. (optional)
    * @param status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @return ApiResponse<kotlin.Int?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun operationsGetTransactionsCountWithHttpInfo(level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = operationsGetTransactionsCountRequestConfig(level = level, timestamp = timestamp, status = status)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation operationsGetTransactionsCount
    *
    * @param level Filters transactions by level. (optional)
    * @param timestamp Filters transactions by timestamp. (optional)
    * @param status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
    * @return RequestConfig
    */
    fun operationsGetTransactionsCountRequestConfig(level: IntParameter?, timestamp: DateTimeParameter?, status: OperationStatusParameter?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (level != null) {
                    put("level", listOf(level.toString()))
                }
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/operations/transactions/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
