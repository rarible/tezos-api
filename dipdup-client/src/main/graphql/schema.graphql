"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean

  _gt: Boolean

  _gte: Boolean

  _in: [Boolean!]

  _is_null: Boolean

  _lt: Boolean

  _lte: Boolean

  _neq: Boolean

  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int

  _gt: Int

  _gte: Int

  _in: [Int!]

  _is_null: Boolean

  _lt: Int

  _lte: Int

  _neq: Int

  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String

  _gt: String

  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String

  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String

  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String

  _lt: String

  _lte: String

  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String

  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
columns and relationships of "dipdup_contract"
"""
type dipdup_contract {
  address: String!

  created_at: timestamptz!

  name: String!

  typename: String

  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_contract"
"""
type dipdup_contract_aggregate {
  aggregate: dipdup_contract_aggregate_fields

  nodes: [dipdup_contract!]!
}

"""
aggregate fields of "dipdup_contract"
"""
type dipdup_contract_aggregate_fields {
  count(columns: [dipdup_contract_select_column!], distinct: Boolean): Int!

  max: dipdup_contract_max_fields

  min: dipdup_contract_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_contract". All fields are combined with a logical 'AND'.
"""
input dipdup_contract_bool_exp {
  _and: [dipdup_contract_bool_exp!]

  _not: dipdup_contract_bool_exp

  _or: [dipdup_contract_bool_exp!]

  address: String_comparison_exp

  created_at: timestamptz_comparison_exp

  name: String_comparison_exp

  typename: String_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
aggregate max on columns
"""
type dipdup_contract_max_fields {
  address: String

  created_at: timestamptz

  name: String

  typename: String

  updated_at: timestamptz
}

"""
columns and relationships of "dipdup_contract_metadata"
"""
type dipdup_contract_metadata {
  contract: String!

  created_at: timestamptz!

  id: Int!

  metadata("JSON select path" path: String): jsonb!

  network: String!

  update_id: Int!

  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_contract_metadata"
"""
type dipdup_contract_metadata_aggregate {
  aggregate: dipdup_contract_metadata_aggregate_fields

  nodes: [dipdup_contract_metadata!]!
}

"""
aggregate fields of "dipdup_contract_metadata"
"""
type dipdup_contract_metadata_aggregate_fields {
  avg: dipdup_contract_metadata_avg_fields

  count(columns: [dipdup_contract_metadata_select_column!], distinct: Boolean): Int!

  max: dipdup_contract_metadata_max_fields

  min: dipdup_contract_metadata_min_fields

  stddev: dipdup_contract_metadata_stddev_fields

  stddev_pop: dipdup_contract_metadata_stddev_pop_fields

  stddev_samp: dipdup_contract_metadata_stddev_samp_fields

  sum: dipdup_contract_metadata_sum_fields

  var_pop: dipdup_contract_metadata_var_pop_fields

  var_samp: dipdup_contract_metadata_var_samp_fields

  variance: dipdup_contract_metadata_variance_fields
}

"""
aggregate avg on columns
"""
type dipdup_contract_metadata_avg_fields {
  id: Float

  update_id: Float
}

"""
Boolean expression to filter rows from the table "dipdup_contract_metadata". All fields are combined with a logical 'AND'.
"""
input dipdup_contract_metadata_bool_exp {
  _and: [dipdup_contract_metadata_bool_exp!]

  _not: dipdup_contract_metadata_bool_exp

  _or: [dipdup_contract_metadata_bool_exp!]

  contract: String_comparison_exp

  created_at: timestamptz_comparison_exp

  id: Int_comparison_exp

  metadata: jsonb_comparison_exp

  network: String_comparison_exp

  update_id: Int_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
aggregate max on columns
"""
type dipdup_contract_metadata_max_fields {
  contract: String

  created_at: timestamptz

  id: Int

  network: String

  update_id: Int

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type dipdup_contract_metadata_min_fields {
  contract: String

  created_at: timestamptz

  id: Int

  network: String

  update_id: Int

  updated_at: timestamptz
}

"""
Ordering options when selecting data from "dipdup_contract_metadata".
"""
input dipdup_contract_metadata_order_by {
  contract: order_by

  created_at: order_by

  id: order_by

  metadata: order_by

  network: order_by

  update_id: order_by

  updated_at: order_by
}

"""
select columns of table "dipdup_contract_metadata"
"""
enum dipdup_contract_metadata_select_column {
  """
  column name
  """
  contract

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  metadata

  """
  column name
  """
  network

  """
  column name
  """
  update_id

  """
  column name
  """
  updated_at
}

"""
aggregate stddev on columns
"""
type dipdup_contract_metadata_stddev_fields {
  id: Float

  update_id: Float
}

"""
aggregate stddev_pop on columns
"""
type dipdup_contract_metadata_stddev_pop_fields {
  id: Float

  update_id: Float
}

"""
aggregate stddev_samp on columns
"""
type dipdup_contract_metadata_stddev_samp_fields {
  id: Float

  update_id: Float
}

"""
aggregate sum on columns
"""
type dipdup_contract_metadata_sum_fields {
  id: Int

  update_id: Int
}

"""
aggregate var_pop on columns
"""
type dipdup_contract_metadata_var_pop_fields {
  id: Float

  update_id: Float
}

"""
aggregate var_samp on columns
"""
type dipdup_contract_metadata_var_samp_fields {
  id: Float

  update_id: Float
}

"""
aggregate variance on columns
"""
type dipdup_contract_metadata_variance_fields {
  id: Float

  update_id: Float
}

"""
aggregate min on columns
"""
type dipdup_contract_min_fields {
  address: String

  created_at: timestamptz

  name: String

  typename: String

  updated_at: timestamptz
}

"""
Ordering options when selecting data from "dipdup_contract".
"""
input dipdup_contract_order_by {
  address: order_by

  created_at: order_by

  name: order_by

  typename: order_by

  updated_at: order_by
}

"""
select columns of table "dipdup_contract"
"""
enum dipdup_contract_select_column {
  """
  column name
  """
  address

  """
  column name
  """
  created_at

  """
  column name
  """
  name

  """
  column name
  """
  typename

  """
  column name
  """
  updated_at
}

"""
columns and relationships of "dipdup_head"
"""
type dipdup_head {
  created_at: timestamptz!

  hash: String!

  level: Int!

  name: String!

  timestamp: timestamptz!

  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_head"
"""
type dipdup_head_aggregate {
  aggregate: dipdup_head_aggregate_fields

  nodes: [dipdup_head!]!
}

"""
aggregate fields of "dipdup_head"
"""
type dipdup_head_aggregate_fields {
  avg: dipdup_head_avg_fields

  count(columns: [dipdup_head_select_column!], distinct: Boolean): Int!

  max: dipdup_head_max_fields

  min: dipdup_head_min_fields

  stddev: dipdup_head_stddev_fields

  stddev_pop: dipdup_head_stddev_pop_fields

  stddev_samp: dipdup_head_stddev_samp_fields

  sum: dipdup_head_sum_fields

  var_pop: dipdup_head_var_pop_fields

  var_samp: dipdup_head_var_samp_fields

  variance: dipdup_head_variance_fields
}

"""
aggregate avg on columns
"""
type dipdup_head_avg_fields {
  level: Float
}

"""
Boolean expression to filter rows from the table "dipdup_head". All fields are combined with a logical 'AND'.
"""
input dipdup_head_bool_exp {
  _and: [dipdup_head_bool_exp!]

  _not: dipdup_head_bool_exp

  _or: [dipdup_head_bool_exp!]

  created_at: timestamptz_comparison_exp

  hash: String_comparison_exp

  level: Int_comparison_exp

  name: String_comparison_exp

  timestamp: timestamptz_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
aggregate max on columns
"""
type dipdup_head_max_fields {
  created_at: timestamptz

  hash: String

  level: Int

  name: String

  timestamp: timestamptz

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type dipdup_head_min_fields {
  created_at: timestamptz

  hash: String

  level: Int

  name: String

  timestamp: timestamptz

  updated_at: timestamptz
}

"""
Ordering options when selecting data from "dipdup_head".
"""
input dipdup_head_order_by {
  created_at: order_by

  hash: order_by

  level: order_by

  name: order_by

  timestamp: order_by

  updated_at: order_by
}

"""
select columns of table "dipdup_head"
"""
enum dipdup_head_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  hash

  """
  column name
  """
  level

  """
  column name
  """
  name

  """
  column name
  """
  timestamp

  """
  column name
  """
  updated_at
}

"""
columns and relationships of "dipdup_head_status"
"""
type dipdup_head_status {
  name: String

  status: String
}

"""
aggregated selection of "dipdup_head_status"
"""
type dipdup_head_status_aggregate {
  aggregate: dipdup_head_status_aggregate_fields

  nodes: [dipdup_head_status!]!
}

"""
aggregate fields of "dipdup_head_status"
"""
type dipdup_head_status_aggregate_fields {
  count(columns: [dipdup_head_status_select_column!], distinct: Boolean): Int!

  max: dipdup_head_status_max_fields

  min: dipdup_head_status_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_head_status". All fields are combined with a logical 'AND'.
"""
input dipdup_head_status_bool_exp {
  _and: [dipdup_head_status_bool_exp!]

  _not: dipdup_head_status_bool_exp

  _or: [dipdup_head_status_bool_exp!]

  name: String_comparison_exp

  status: String_comparison_exp
}

"""
aggregate max on columns
"""
type dipdup_head_status_max_fields {
  name: String

  status: String
}

"""
aggregate min on columns
"""
type dipdup_head_status_min_fields {
  name: String

  status: String
}

"""
Ordering options when selecting data from "dipdup_head_status".
"""
input dipdup_head_status_order_by {
  name: order_by

  status: order_by
}

"""
select columns of table "dipdup_head_status"
"""
enum dipdup_head_status_select_column {
  """
  column name
  """
  name

  """
  column name
  """
  status
}

"""
aggregate stddev on columns
"""
type dipdup_head_stddev_fields {
  level: Float
}

"""
aggregate stddev_pop on columns
"""
type dipdup_head_stddev_pop_fields {
  level: Float
}

"""
aggregate stddev_samp on columns
"""
type dipdup_head_stddev_samp_fields {
  level: Float
}

"""
aggregate sum on columns
"""
type dipdup_head_sum_fields {
  level: Int
}

"""
aggregate var_pop on columns
"""
type dipdup_head_var_pop_fields {
  level: Float
}

"""
aggregate var_samp on columns
"""
type dipdup_head_var_samp_fields {
  level: Float
}

"""
aggregate variance on columns
"""
type dipdup_head_variance_fields {
  level: Float
}

"""
columns and relationships of "dipdup_index"
"""
type dipdup_index {
  config_hash: String!

  created_at: timestamptz!

  level: Int!

  name: String!

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String!

  template: String

  template_values("JSON select path" path: String): jsonb

  """
  operation: operation\nbig_map: big_map\nhead: head\ntoken_transfer: token_transfer
  """
  type: String!

  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_index"
"""
type dipdup_index_aggregate {
  aggregate: dipdup_index_aggregate_fields

  nodes: [dipdup_index!]!
}

"""
aggregate fields of "dipdup_index"
"""
type dipdup_index_aggregate_fields {
  avg: dipdup_index_avg_fields

  count(columns: [dipdup_index_select_column!], distinct: Boolean): Int!

  max: dipdup_index_max_fields

  min: dipdup_index_min_fields

  stddev: dipdup_index_stddev_fields

  stddev_pop: dipdup_index_stddev_pop_fields

  stddev_samp: dipdup_index_stddev_samp_fields

  sum: dipdup_index_sum_fields

  var_pop: dipdup_index_var_pop_fields

  var_samp: dipdup_index_var_samp_fields

  variance: dipdup_index_variance_fields
}

"""
aggregate avg on columns
"""
type dipdup_index_avg_fields {
  level: Float
}

"""
Boolean expression to filter rows from the table "dipdup_index". All fields are combined with a logical 'AND'.
"""
input dipdup_index_bool_exp {
  _and: [dipdup_index_bool_exp!]

  _not: dipdup_index_bool_exp

  _or: [dipdup_index_bool_exp!]

  config_hash: String_comparison_exp

  created_at: timestamptz_comparison_exp

  level: Int_comparison_exp

  name: String_comparison_exp

  status: String_comparison_exp

  template: String_comparison_exp

  template_values: jsonb_comparison_exp

  type: String_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
aggregate max on columns
"""
type dipdup_index_max_fields {
  config_hash: String

  created_at: timestamptz

  level: Int

  name: String

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String

  template: String

  """
  operation: operation\nbig_map: big_map\nhead: head\ntoken_transfer: token_transfer
  """
  type: String

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type dipdup_index_min_fields {
  config_hash: String

  created_at: timestamptz

  level: Int

  name: String

  """
  NEW: NEW\nSYNCING: SYNCING\nREALTIME: REALTIME\nROLLBACK: ROLLBACK\nONESHOT: ONESHOT
  """
  status: String

  template: String

  """
  operation: operation\nbig_map: big_map\nhead: head\ntoken_transfer: token_transfer
  """
  type: String

  updated_at: timestamptz
}

"""
Ordering options when selecting data from "dipdup_index".
"""
input dipdup_index_order_by {
  config_hash: order_by

  created_at: order_by

  level: order_by

  name: order_by

  status: order_by

  template: order_by

  template_values: order_by

  type: order_by

  updated_at: order_by
}

"""
select columns of table "dipdup_index"
"""
enum dipdup_index_select_column {
  """
  column name
  """
  config_hash

  """
  column name
  """
  created_at

  """
  column name
  """
  level

  """
  column name
  """
  name

  """
  column name
  """
  status

  """
  column name
  """
  template

  """
  column name
  """
  template_values

  """
  column name
  """
  type

  """
  column name
  """
  updated_at
}

"""
aggregate stddev on columns
"""
type dipdup_index_stddev_fields {
  level: Float
}

"""
aggregate stddev_pop on columns
"""
type dipdup_index_stddev_pop_fields {
  level: Float
}

"""
aggregate stddev_samp on columns
"""
type dipdup_index_stddev_samp_fields {
  level: Float
}

"""
aggregate sum on columns
"""
type dipdup_index_sum_fields {
  level: Int
}

"""
aggregate var_pop on columns
"""
type dipdup_index_var_pop_fields {
  level: Float
}

"""
aggregate var_samp on columns
"""
type dipdup_index_var_samp_fields {
  level: Float
}

"""
aggregate variance on columns
"""
type dipdup_index_variance_fields {
  level: Float
}

"""
columns and relationships of "dipdup_schema"
"""
type dipdup_schema {
  created_at: timestamptz!

  hash: String!

  name: String!

  """
  manual: manual\nmigration: migration\nrollback: rollback\nconfig_modified: config_modified\nschema_modified: schema_modified
  """
  reindex: String

  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_schema"
"""
type dipdup_schema_aggregate {
  aggregate: dipdup_schema_aggregate_fields

  nodes: [dipdup_schema!]!
}

"""
aggregate fields of "dipdup_schema"
"""
type dipdup_schema_aggregate_fields {
  count(columns: [dipdup_schema_select_column!], distinct: Boolean): Int!

  max: dipdup_schema_max_fields

  min: dipdup_schema_min_fields
}

"""
Boolean expression to filter rows from the table "dipdup_schema". All fields are combined with a logical 'AND'.
"""
input dipdup_schema_bool_exp {
  _and: [dipdup_schema_bool_exp!]

  _not: dipdup_schema_bool_exp

  _or: [dipdup_schema_bool_exp!]

  created_at: timestamptz_comparison_exp

  hash: String_comparison_exp

  name: String_comparison_exp

  reindex: String_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
aggregate max on columns
"""
type dipdup_schema_max_fields {
  created_at: timestamptz

  hash: String

  name: String

  """
  manual: manual\nmigration: migration\nrollback: rollback\nconfig_modified: config_modified\nschema_modified: schema_modified
  """
  reindex: String

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type dipdup_schema_min_fields {
  created_at: timestamptz

  hash: String

  name: String

  """
  manual: manual\nmigration: migration\nrollback: rollback\nconfig_modified: config_modified\nschema_modified: schema_modified
  """
  reindex: String

  updated_at: timestamptz
}

"""
Ordering options when selecting data from "dipdup_schema".
"""
input dipdup_schema_order_by {
  created_at: order_by

  hash: order_by

  name: order_by

  reindex: order_by

  updated_at: order_by
}

"""
select columns of table "dipdup_schema"
"""
enum dipdup_schema_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  hash

  """
  column name
  """
  name

  """
  column name
  """
  reindex

  """
  column name
  """
  updated_at
}

"""
columns and relationships of "dipdup_token_metadata"
"""
type dipdup_token_metadata {
  contract: String!

  created_at: timestamptz!

  id: Int!

  metadata("JSON select path" path: String): jsonb!

  network: String!

  token_id: String!

  update_id: Int!

  updated_at: timestamptz!
}

"""
aggregated selection of "dipdup_token_metadata"
"""
type dipdup_token_metadata_aggregate {
  aggregate: dipdup_token_metadata_aggregate_fields

  nodes: [dipdup_token_metadata!]!
}

"""
aggregate fields of "dipdup_token_metadata"
"""
type dipdup_token_metadata_aggregate_fields {
  avg: dipdup_token_metadata_avg_fields

  count(columns: [dipdup_token_metadata_select_column!], distinct: Boolean): Int!

  max: dipdup_token_metadata_max_fields

  min: dipdup_token_metadata_min_fields

  stddev: dipdup_token_metadata_stddev_fields

  stddev_pop: dipdup_token_metadata_stddev_pop_fields

  stddev_samp: dipdup_token_metadata_stddev_samp_fields

  sum: dipdup_token_metadata_sum_fields

  var_pop: dipdup_token_metadata_var_pop_fields

  var_samp: dipdup_token_metadata_var_samp_fields

  variance: dipdup_token_metadata_variance_fields
}

"""
aggregate avg on columns
"""
type dipdup_token_metadata_avg_fields {
  id: Float

  update_id: Float
}

"""
Boolean expression to filter rows from the table "dipdup_token_metadata". All fields are combined with a logical 'AND'.
"""
input dipdup_token_metadata_bool_exp {
  _and: [dipdup_token_metadata_bool_exp!]

  _not: dipdup_token_metadata_bool_exp

  _or: [dipdup_token_metadata_bool_exp!]

  contract: String_comparison_exp

  created_at: timestamptz_comparison_exp

  id: Int_comparison_exp

  metadata: jsonb_comparison_exp

  network: String_comparison_exp

  token_id: String_comparison_exp

  update_id: Int_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
aggregate max on columns
"""
type dipdup_token_metadata_max_fields {
  contract: String

  created_at: timestamptz

  id: Int

  network: String

  token_id: String

  update_id: Int

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type dipdup_token_metadata_min_fields {
  contract: String

  created_at: timestamptz

  id: Int

  network: String

  token_id: String

  update_id: Int

  updated_at: timestamptz
}

"""
Ordering options when selecting data from "dipdup_token_metadata".
"""
input dipdup_token_metadata_order_by {
  contract: order_by

  created_at: order_by

  id: order_by

  metadata: order_by

  network: order_by

  token_id: order_by

  update_id: order_by

  updated_at: order_by
}

"""
select columns of table "dipdup_token_metadata"
"""
enum dipdup_token_metadata_select_column {
  """
  column name
  """
  contract

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  metadata

  """
  column name
  """
  network

  """
  column name
  """
  token_id

  """
  column name
  """
  update_id

  """
  column name
  """
  updated_at
}

"""
aggregate stddev on columns
"""
type dipdup_token_metadata_stddev_fields {
  id: Float

  update_id: Float
}

"""
aggregate stddev_pop on columns
"""
type dipdup_token_metadata_stddev_pop_fields {
  id: Float

  update_id: Float
}

"""
aggregate stddev_samp on columns
"""
type dipdup_token_metadata_stddev_samp_fields {
  id: Float

  update_id: Float
}

"""
aggregate sum on columns
"""
type dipdup_token_metadata_sum_fields {
  id: Int

  update_id: Int
}

"""
aggregate var_pop on columns
"""
type dipdup_token_metadata_var_pop_fields {
  id: Float

  update_id: Float
}

"""
aggregate var_samp on columns
"""
type dipdup_token_metadata_var_samp_fields {
  id: Float

  update_id: Float
}

"""
aggregate variance on columns
"""
type dipdup_token_metadata_variance_fields {
  id: Float

  update_id: Float
}

"""
columns and relationships of "indexing_status"
"""
type indexing_status {
  """
  COLLECTION: COLLECTION\nLEGACY_ORDERS: LEGACY_ORDERS
  """
  index: String!

  last_level: String!
}

"""
aggregated selection of "indexing_status"
"""
type indexing_status_aggregate {
  aggregate: indexing_status_aggregate_fields

  nodes: [indexing_status!]!
}

"""
aggregate fields of "indexing_status"
"""
type indexing_status_aggregate_fields {
  count(columns: [indexing_status_select_column!], distinct: Boolean): Int!

  max: indexing_status_max_fields

  min: indexing_status_min_fields
}

"""
Boolean expression to filter rows from the table "indexing_status". All fields are combined with a logical 'AND'.
"""
input indexing_status_bool_exp {
  _and: [indexing_status_bool_exp!]

  _not: indexing_status_bool_exp

  _or: [indexing_status_bool_exp!]

  index: String_comparison_exp

  last_level: String_comparison_exp
}

"""
aggregate max on columns
"""
type indexing_status_max_fields {
  """
  COLLECTION: COLLECTION\nLEGACY_ORDERS: LEGACY_ORDERS
  """
  index: String

  last_level: String
}

"""
aggregate min on columns
"""
type indexing_status_min_fields {
  """
  COLLECTION: COLLECTION\nLEGACY_ORDERS: LEGACY_ORDERS
  """
  index: String

  last_level: String
}

"""
Ordering options when selecting data from "indexing_status".
"""
input indexing_status_order_by {
  index: order_by

  last_level: order_by
}

"""
select columns of table "indexing_status"
"""
enum indexing_status_select_column {
  """
  column name
  """
  index

  """
  column name
  """
  last_level
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb

  _eq: jsonb

  _gt: jsonb

  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]

  _in: [jsonb!]

  _is_null: Boolean

  _lt: jsonb

  _lte: jsonb

  _neq: jsonb

  _nin: [jsonb!]
}

"""
columns and relationships of "legacy_orders"
"""
type legacy_orders {
  data("JSON select path" path: String): jsonb!

  hash: String!

  id: uuid!
}

"""
aggregated selection of "legacy_orders"
"""
type legacy_orders_aggregate {
  aggregate: legacy_orders_aggregate_fields

  nodes: [legacy_orders!]!
}

"""
aggregate fields of "legacy_orders"
"""
type legacy_orders_aggregate_fields {
  count(columns: [legacy_orders_select_column!], distinct: Boolean): Int!

  max: legacy_orders_max_fields

  min: legacy_orders_min_fields
}

"""
Boolean expression to filter rows from the table "legacy_orders". All fields are combined with a logical 'AND'.
"""
input legacy_orders_bool_exp {
  _and: [legacy_orders_bool_exp!]

  _not: legacy_orders_bool_exp

  _or: [legacy_orders_bool_exp!]

  data: jsonb_comparison_exp

  hash: String_comparison_exp

  id: uuid_comparison_exp
}

"""
aggregate max on columns
"""
type legacy_orders_max_fields {
  hash: String

  id: uuid
}

"""
aggregate min on columns
"""
type legacy_orders_min_fields {
  hash: String

  id: uuid
}

"""
Ordering options when selecting data from "legacy_orders".
"""
input legacy_orders_order_by {
  data: order_by

  hash: order_by

  id: order_by
}

"""
select columns of table "legacy_orders"
"""
enum legacy_orders_select_column {
  """
  column name
  """
  data

  """
  column name
  """
  hash

  """
  column name
  """
  id
}

"""
columns and relationships of "marketplace_activity"
"""
type marketplace_activity {
  id: uuid!

  internal_order_id: String!

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  make_asset_class: String!

  make_contract: String

  make_token_id: String

  make_value: numeric!

  maker: String

  network: String!

  operation_counter: Int!

  operation_hash: String!

  operation_level: Int!

  operation_nonce: Int

  operation_timestamp: timestamptz!

  order_id: uuid!

  """
  HEN: HEN\nOBJKT: OBJKT\nOBJKT_V2: OBJKT_V2\nRARIBLE_V1: RARIBLE_V1\nRARIBLE_V2: RARIBLE_V2
  """
  platform: String!

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  take_asset_class: String

  take_contract: String

  take_token_id: String

  take_value: numeric

  taker: String

  """
  GET_BID: GET_BID\nGET_FLOOR_BID: GET_FLOOR_BID\nORDER_LIST: LIST\nORDER_MATCH: SELL\nORDER_CANCEL: CANCEL_LIST\nCANCEL_BID: CANCEL_BID\nCANCEL_FLOOR_BID: CANCEL_FLOOR_BID\nMAKE_BID: MAKE_BID\nMAKE_FLOOR_BID: MAKE_FLOOR_BID\nTOKEN_MINT: MINT\nTOKEN_TRANSFER: TRANSFER\nTOKEN_BURN: BURN
  """
  type: String!
}

"""
aggregated selection of "marketplace_activity"
"""
type marketplace_activity_aggregate {
  aggregate: marketplace_activity_aggregate_fields

  nodes: [marketplace_activity!]!
}

"""
aggregate fields of "marketplace_activity"
"""
type marketplace_activity_aggregate_fields {
  avg: marketplace_activity_avg_fields

  count(columns: [marketplace_activity_select_column!], distinct: Boolean): Int!

  max: marketplace_activity_max_fields

  min: marketplace_activity_min_fields

  stddev: marketplace_activity_stddev_fields

  stddev_pop: marketplace_activity_stddev_pop_fields

  stddev_samp: marketplace_activity_stddev_samp_fields

  sum: marketplace_activity_sum_fields

  var_pop: marketplace_activity_var_pop_fields

  var_samp: marketplace_activity_var_samp_fields

  variance: marketplace_activity_variance_fields
}

"""
aggregate avg on columns
"""
type marketplace_activity_avg_fields {
  make_value: Float

  operation_counter: Float

  operation_level: Float

  operation_nonce: Float

  take_value: Float
}

"""
Boolean expression to filter rows from the table "marketplace_activity". All fields are combined with a logical 'AND'.
"""
input marketplace_activity_bool_exp {
  _and: [marketplace_activity_bool_exp!]

  _not: marketplace_activity_bool_exp

  _or: [marketplace_activity_bool_exp!]

  id: uuid_comparison_exp

  internal_order_id: String_comparison_exp

  make_asset_class: String_comparison_exp

  make_contract: String_comparison_exp

  make_token_id: String_comparison_exp

  make_value: numeric_comparison_exp

  maker: String_comparison_exp

  network: String_comparison_exp

  operation_counter: Int_comparison_exp

  operation_hash: String_comparison_exp

  operation_level: Int_comparison_exp

  operation_nonce: Int_comparison_exp

  operation_timestamp: timestamptz_comparison_exp

  order_id: uuid_comparison_exp

  platform: String_comparison_exp

  take_asset_class: String_comparison_exp

  take_contract: String_comparison_exp

  take_token_id: String_comparison_exp

  take_value: numeric_comparison_exp

  taker: String_comparison_exp

  type: String_comparison_exp
}

"""
aggregate max on columns
"""
type marketplace_activity_max_fields {
  id: uuid

  internal_order_id: String

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  make_asset_class: String

  make_contract: String

  make_token_id: String

  make_value: numeric

  maker: String

  network: String

  operation_counter: Int

  operation_hash: String

  operation_level: Int

  operation_nonce: Int

  operation_timestamp: timestamptz

  order_id: uuid

  """
  HEN: HEN\nOBJKT: OBJKT\nOBJKT_V2: OBJKT_V2\nRARIBLE_V1: RARIBLE_V1\nRARIBLE_V2: RARIBLE_V2
  """
  platform: String

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  take_asset_class: String

  take_contract: String

  take_token_id: String

  take_value: numeric

  taker: String

  """
  GET_BID: GET_BID\nGET_FLOOR_BID: GET_FLOOR_BID\nORDER_LIST: LIST\nORDER_MATCH: SELL\nORDER_CANCEL: CANCEL_LIST\nCANCEL_BID: CANCEL_BID\nCANCEL_FLOOR_BID: CANCEL_FLOOR_BID\nMAKE_BID: MAKE_BID\nMAKE_FLOOR_BID: MAKE_FLOOR_BID\nTOKEN_MINT: MINT\nTOKEN_TRANSFER: TRANSFER\nTOKEN_BURN: BURN
  """
  type: String
}

"""
aggregate min on columns
"""
type marketplace_activity_min_fields {
  id: uuid

  internal_order_id: String

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  make_asset_class: String

  make_contract: String

  make_token_id: String

  make_value: numeric

  maker: String

  network: String

  operation_counter: Int

  operation_hash: String

  operation_level: Int

  operation_nonce: Int

  operation_timestamp: timestamptz

  order_id: uuid

  """
  HEN: HEN\nOBJKT: OBJKT\nOBJKT_V2: OBJKT_V2\nRARIBLE_V1: RARIBLE_V1\nRARIBLE_V2: RARIBLE_V2
  """
  platform: String

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  take_asset_class: String

  take_contract: String

  take_token_id: String

  take_value: numeric

  taker: String

  """
  GET_BID: GET_BID\nGET_FLOOR_BID: GET_FLOOR_BID\nORDER_LIST: LIST\nORDER_MATCH: SELL\nORDER_CANCEL: CANCEL_LIST\nCANCEL_BID: CANCEL_BID\nCANCEL_FLOOR_BID: CANCEL_FLOOR_BID\nMAKE_BID: MAKE_BID\nMAKE_FLOOR_BID: MAKE_FLOOR_BID\nTOKEN_MINT: MINT\nTOKEN_TRANSFER: TRANSFER\nTOKEN_BURN: BURN
  """
  type: String
}

"""
Ordering options when selecting data from "marketplace_activity".
"""
input marketplace_activity_order_by {
  id: order_by

  internal_order_id: order_by

  make_asset_class: order_by

  make_contract: order_by

  make_token_id: order_by

  make_value: order_by

  maker: order_by

  network: order_by

  operation_counter: order_by

  operation_hash: order_by

  operation_level: order_by

  operation_nonce: order_by

  operation_timestamp: order_by

  order_id: order_by

  platform: order_by

  take_asset_class: order_by

  take_contract: order_by

  take_token_id: order_by

  take_value: order_by

  taker: order_by

  type: order_by
}

"""
select columns of table "marketplace_activity"
"""
enum marketplace_activity_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  internal_order_id

  """
  column name
  """
  make_asset_class

  """
  column name
  """
  make_contract

  """
  column name
  """
  make_token_id

  """
  column name
  """
  make_value

  """
  column name
  """
  maker

  """
  column name
  """
  network

  """
  column name
  """
  operation_counter

  """
  column name
  """
  operation_hash

  """
  column name
  """
  operation_level

  """
  column name
  """
  operation_nonce

  """
  column name
  """
  operation_timestamp

  """
  column name
  """
  order_id

  """
  column name
  """
  platform

  """
  column name
  """
  take_asset_class

  """
  column name
  """
  take_contract

  """
  column name
  """
  take_token_id

  """
  column name
  """
  take_value

  """
  column name
  """
  taker

  """
  column name
  """
  type
}

"""
aggregate stddev on columns
"""
type marketplace_activity_stddev_fields {
  make_value: Float

  operation_counter: Float

  operation_level: Float

  operation_nonce: Float

  take_value: Float
}

"""
aggregate stddev_pop on columns
"""
type marketplace_activity_stddev_pop_fields {
  make_value: Float

  operation_counter: Float

  operation_level: Float

  operation_nonce: Float

  take_value: Float
}

"""
aggregate stddev_samp on columns
"""
type marketplace_activity_stddev_samp_fields {
  make_value: Float

  operation_counter: Float

  operation_level: Float

  operation_nonce: Float

  take_value: Float
}

"""
aggregate sum on columns
"""
type marketplace_activity_sum_fields {
  make_value: numeric

  operation_counter: Int

  operation_level: Int

  operation_nonce: Int

  take_value: numeric
}

"""
aggregate var_pop on columns
"""
type marketplace_activity_var_pop_fields {
  make_value: Float

  operation_counter: Float

  operation_level: Float

  operation_nonce: Float

  take_value: Float
}

"""
aggregate var_samp on columns
"""
type marketplace_activity_var_samp_fields {
  make_value: Float

  operation_counter: Float

  operation_level: Float

  operation_nonce: Float

  take_value: Float
}

"""
aggregate variance on columns
"""
type marketplace_activity_variance_fields {
  make_value: Float

  operation_counter: Float

  operation_level: Float

  operation_nonce: Float

  take_value: Float
}

"""
columns and relationships of "marketplace_order"
"""
type marketplace_order {
  cancelled: Boolean!

  created_at: timestamptz!

  end_at: timestamptz

  ended_at: timestamptz

  fill: numeric!

  id: uuid!

  internal_order_id: String!

  last_updated_at: timestamptz!

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  make_asset_class: String!

  make_contract: String

  make_price: numeric

  make_token_id: String

  make_value: numeric!

  maker: String!

  network: String!

  origin_fees("JSON select path" path: String): jsonb!

  payouts("JSON select path" path: String): jsonb!

  """
  HEN: HEN\nOBJKT: OBJKT\nOBJKT_V2: OBJKT_V2\nRARIBLE_V1: RARIBLE_V1\nRARIBLE_V2: RARIBLE_V2
  """
  platform: String!

  salt: String!

  start_at: timestamptz!

  """
  ACTIVE: ACTIVE\nFILLED: FILLED\nHISTORICAL: HISTORICAL\nINACTIVE: INACTIVE\nCANCELLED: CANCELLED
  """
  status: String!

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  take_asset_class: String

  take_contract: String

  take_price: numeric

  take_token_id: String

  take_value: numeric

  taker: String
}

"""
aggregated selection of "marketplace_order"
"""
type marketplace_order_aggregate {
  aggregate: marketplace_order_aggregate_fields

  nodes: [marketplace_order!]!
}

"""
aggregate fields of "marketplace_order"
"""
type marketplace_order_aggregate_fields {
  avg: marketplace_order_avg_fields

  count(columns: [marketplace_order_select_column!], distinct: Boolean): Int!

  max: marketplace_order_max_fields

  min: marketplace_order_min_fields

  stddev: marketplace_order_stddev_fields

  stddev_pop: marketplace_order_stddev_pop_fields

  stddev_samp: marketplace_order_stddev_samp_fields

  sum: marketplace_order_sum_fields

  var_pop: marketplace_order_var_pop_fields

  var_samp: marketplace_order_var_samp_fields

  variance: marketplace_order_variance_fields
}

"""
aggregate avg on columns
"""
type marketplace_order_avg_fields {
  fill: Float

  make_price: Float

  make_value: Float

  take_price: Float

  take_value: Float
}

"""
Boolean expression to filter rows from the table "marketplace_order". All fields are combined with a logical 'AND'.
"""
input marketplace_order_bool_exp {
  _and: [marketplace_order_bool_exp!]

  _not: marketplace_order_bool_exp

  _or: [marketplace_order_bool_exp!]

  cancelled: Boolean_comparison_exp

  created_at: timestamptz_comparison_exp

  end_at: timestamptz_comparison_exp

  ended_at: timestamptz_comparison_exp

  fill: numeric_comparison_exp

  id: uuid_comparison_exp

  internal_order_id: String_comparison_exp

  last_updated_at: timestamptz_comparison_exp

  make_asset_class: String_comparison_exp

  make_contract: String_comparison_exp

  make_price: numeric_comparison_exp

  make_token_id: String_comparison_exp

  make_value: numeric_comparison_exp

  maker: String_comparison_exp

  network: String_comparison_exp

  origin_fees: jsonb_comparison_exp

  payouts: jsonb_comparison_exp

  platform: String_comparison_exp

  salt: String_comparison_exp

  start_at: timestamptz_comparison_exp

  status: String_comparison_exp

  take_asset_class: String_comparison_exp

  take_contract: String_comparison_exp

  take_price: numeric_comparison_exp

  take_token_id: String_comparison_exp

  take_value: numeric_comparison_exp

  taker: String_comparison_exp
}

"""
aggregate max on columns
"""
type marketplace_order_max_fields {
  created_at: timestamptz

  end_at: timestamptz

  ended_at: timestamptz

  fill: numeric

  id: uuid

  internal_order_id: String

  last_updated_at: timestamptz

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  make_asset_class: String

  make_contract: String

  make_price: numeric

  make_token_id: String

  make_value: numeric

  maker: String

  network: String

  """
  HEN: HEN\nOBJKT: OBJKT\nOBJKT_V2: OBJKT_V2\nRARIBLE_V1: RARIBLE_V1\nRARIBLE_V2: RARIBLE_V2
  """
  platform: String

  salt: String

  start_at: timestamptz

  """
  ACTIVE: ACTIVE\nFILLED: FILLED\nHISTORICAL: HISTORICAL\nINACTIVE: INACTIVE\nCANCELLED: CANCELLED
  """
  status: String

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  take_asset_class: String

  take_contract: String

  take_price: numeric

  take_token_id: String

  take_value: numeric

  taker: String
}

"""
aggregate min on columns
"""
type marketplace_order_min_fields {
  created_at: timestamptz

  end_at: timestamptz

  ended_at: timestamptz

  fill: numeric

  id: uuid

  internal_order_id: String

  last_updated_at: timestamptz

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  make_asset_class: String

  make_contract: String

  make_price: numeric

  make_token_id: String

  make_value: numeric

  maker: String

  network: String

  """
  HEN: HEN\nOBJKT: OBJKT\nOBJKT_V2: OBJKT_V2\nRARIBLE_V1: RARIBLE_V1\nRARIBLE_V2: RARIBLE_V2
  """
  platform: String

  salt: String

  start_at: timestamptz

  """
  ACTIVE: ACTIVE\nFILLED: FILLED\nHISTORICAL: HISTORICAL\nINACTIVE: INACTIVE\nCANCELLED: CANCELLED
  """
  status: String

  """
  ETH: ETH\nXTZ: XTZ\nFUNGIBLE_TOKEN: TEZOS_FT\nNON_FUNGIBLE_TOKEN: TEZOS_NFT\nMULTI_TOKEN: TEZOS_MT\nERC20: ERC20\nERC721: ERC721\nERC1155: ERC1155\nERC721_LAZY: ERC721_LAZY\nERC1155_LAZY: ERC1155_LAZY\nCOLLECTION: COLLECTION\nGEN_ART: GEN_ART
  """
  take_asset_class: String

  take_contract: String

  take_price: numeric

  take_token_id: String

  take_value: numeric

  taker: String
}

"""
Ordering options when selecting data from "marketplace_order".
"""
input marketplace_order_order_by {
  cancelled: order_by

  created_at: order_by

  end_at: order_by

  ended_at: order_by

  fill: order_by

  id: order_by

  internal_order_id: order_by

  last_updated_at: order_by

  make_asset_class: order_by

  make_contract: order_by

  make_price: order_by

  make_token_id: order_by

  make_value: order_by

  maker: order_by

  network: order_by

  origin_fees: order_by

  payouts: order_by

  platform: order_by

  salt: order_by

  start_at: order_by

  status: order_by

  take_asset_class: order_by

  take_contract: order_by

  take_price: order_by

  take_token_id: order_by

  take_value: order_by

  taker: order_by
}

"""
select columns of table "marketplace_order"
"""
enum marketplace_order_select_column {
  """
  column name
  """
  cancelled

  """
  column name
  """
  created_at

  """
  column name
  """
  end_at

  """
  column name
  """
  ended_at

  """
  column name
  """
  fill

  """
  column name
  """
  id

  """
  column name
  """
  internal_order_id

  """
  column name
  """
  last_updated_at

  """
  column name
  """
  make_asset_class

  """
  column name
  """
  make_contract

  """
  column name
  """
  make_price

  """
  column name
  """
  make_token_id

  """
  column name
  """
  make_value

  """
  column name
  """
  maker

  """
  column name
  """
  network

  """
  column name
  """
  origin_fees

  """
  column name
  """
  payouts

  """
  column name
  """
  platform

  """
  column name
  """
  salt

  """
  column name
  """
  start_at

  """
  column name
  """
  status

  """
  column name
  """
  take_asset_class

  """
  column name
  """
  take_contract

  """
  column name
  """
  take_price

  """
  column name
  """
  take_token_id

  """
  column name
  """
  take_value

  """
  column name
  """
  taker
}

"""
aggregate stddev on columns
"""
type marketplace_order_stddev_fields {
  fill: Float

  make_price: Float

  make_value: Float

  take_price: Float

  take_value: Float
}

"""
aggregate stddev_pop on columns
"""
type marketplace_order_stddev_pop_fields {
  fill: Float

  make_price: Float

  make_value: Float

  take_price: Float

  take_value: Float
}

"""
aggregate stddev_samp on columns
"""
type marketplace_order_stddev_samp_fields {
  fill: Float

  make_price: Float

  make_value: Float

  take_price: Float

  take_value: Float
}

"""
aggregate sum on columns
"""
type marketplace_order_sum_fields {
  fill: numeric

  make_price: numeric

  make_value: numeric

  take_price: numeric

  take_value: numeric
}

"""
aggregate var_pop on columns
"""
type marketplace_order_var_pop_fields {
  fill: Float

  make_price: Float

  make_value: Float

  take_price: Float

  take_value: Float
}

"""
aggregate var_samp on columns
"""
type marketplace_order_var_samp_fields {
  fill: Float

  make_price: Float

  make_value: Float

  take_price: Float

  take_value: Float
}

"""
aggregate variance on columns
"""
type marketplace_order_variance_fields {
  fill: Float

  make_price: Float

  make_value: Float

  take_price: Float

  take_value: Float
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric

  _gt: numeric

  _gte: numeric

  _in: [numeric!]

  _is_null: Boolean

  _lt: numeric

  _lte: numeric

  _neq: numeric

  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "dipdup_contract"
  """
  dipdup_contract("distinct select on columns" distinct_on: [dipdup_contract_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_order_by!], "filter the rows returned" where: dipdup_contract_bool_exp): [dipdup_contract!]!

  """
  fetch aggregated fields from the table: "dipdup_contract"
  """
  dipdup_contract_aggregate("distinct select on columns" distinct_on: [dipdup_contract_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_order_by!], "filter the rows returned" where: dipdup_contract_bool_exp): dipdup_contract_aggregate!

  """
  fetch data from the table: "dipdup_contract" using primary key columns
  """
  dipdup_contract_by_pk(name: String!): dipdup_contract

  """
  fetch data from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata("distinct select on columns" distinct_on: [dipdup_contract_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_metadata_order_by!], "filter the rows returned" where: dipdup_contract_metadata_bool_exp): [dipdup_contract_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata_aggregate("distinct select on columns" distinct_on: [dipdup_contract_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_metadata_order_by!], "filter the rows returned" where: dipdup_contract_metadata_bool_exp): dipdup_contract_metadata_aggregate!

  """
  fetch data from the table: "dipdup_contract_metadata" using primary key columns
  """
  dipdup_contract_metadata_by_pk(id: Int!): dipdup_contract_metadata

  """
  fetch data from the table: "dipdup_head"
  """
  dipdup_head("distinct select on columns" distinct_on: [dipdup_head_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_order_by!], "filter the rows returned" where: dipdup_head_bool_exp): [dipdup_head!]!

  """
  fetch aggregated fields from the table: "dipdup_head"
  """
  dipdup_head_aggregate("distinct select on columns" distinct_on: [dipdup_head_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_order_by!], "filter the rows returned" where: dipdup_head_bool_exp): dipdup_head_aggregate!

  """
  fetch data from the table: "dipdup_head" using primary key columns
  """
  dipdup_head_by_pk(name: String!): dipdup_head

  """
  fetch data from the table: "dipdup_head_status"
  """
  dipdup_head_status("distinct select on columns" distinct_on: [dipdup_head_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_status_order_by!], "filter the rows returned" where: dipdup_head_status_bool_exp): [dipdup_head_status!]!

  """
  fetch aggregated fields from the table: "dipdup_head_status"
  """
  dipdup_head_status_aggregate("distinct select on columns" distinct_on: [dipdup_head_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_status_order_by!], "filter the rows returned" where: dipdup_head_status_bool_exp): dipdup_head_status_aggregate!

  """
  fetch data from the table: "dipdup_index"
  """
  dipdup_index("distinct select on columns" distinct_on: [dipdup_index_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_index_order_by!], "filter the rows returned" where: dipdup_index_bool_exp): [dipdup_index!]!

  """
  fetch aggregated fields from the table: "dipdup_index"
  """
  dipdup_index_aggregate("distinct select on columns" distinct_on: [dipdup_index_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_index_order_by!], "filter the rows returned" where: dipdup_index_bool_exp): dipdup_index_aggregate!

  """
  fetch data from the table: "dipdup_index" using primary key columns
  """
  dipdup_index_by_pk(name: String!): dipdup_index

  """
  fetch data from the table: "dipdup_schema"
  """
  dipdup_schema("distinct select on columns" distinct_on: [dipdup_schema_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_schema_order_by!], "filter the rows returned" where: dipdup_schema_bool_exp): [dipdup_schema!]!

  """
  fetch aggregated fields from the table: "dipdup_schema"
  """
  dipdup_schema_aggregate("distinct select on columns" distinct_on: [dipdup_schema_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_schema_order_by!], "filter the rows returned" where: dipdup_schema_bool_exp): dipdup_schema_aggregate!

  """
  fetch data from the table: "dipdup_schema" using primary key columns
  """
  dipdup_schema_by_pk(name: String!): dipdup_schema

  """
  fetch data from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata("distinct select on columns" distinct_on: [dipdup_token_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_token_metadata_order_by!], "filter the rows returned" where: dipdup_token_metadata_bool_exp): [dipdup_token_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata_aggregate("distinct select on columns" distinct_on: [dipdup_token_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_token_metadata_order_by!], "filter the rows returned" where: dipdup_token_metadata_bool_exp): dipdup_token_metadata_aggregate!

  """
  fetch data from the table: "dipdup_token_metadata" using primary key columns
  """
  dipdup_token_metadata_by_pk(id: Int!): dipdup_token_metadata

  """
  fetch data from the table: "indexing_status"
  """
  indexing_status("distinct select on columns" distinct_on: [indexing_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [indexing_status_order_by!], "filter the rows returned" where: indexing_status_bool_exp): [indexing_status!]!

  """
  fetch aggregated fields from the table: "indexing_status"
  """
  indexing_status_aggregate("distinct select on columns" distinct_on: [indexing_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [indexing_status_order_by!], "filter the rows returned" where: indexing_status_bool_exp): indexing_status_aggregate!

  """
  fetch data from the table: "indexing_status" using primary key columns
  """
  indexing_status_by_pk("COLLECTION: COLLECTION\\nLEGACY_ORDERS: LEGACY_ORDERS" index: String!): indexing_status

  """
  fetch data from the table: "legacy_orders"
  """
  legacy_orders("distinct select on columns" distinct_on: [legacy_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [legacy_orders_order_by!], "filter the rows returned" where: legacy_orders_bool_exp): [legacy_orders!]!

  """
  fetch aggregated fields from the table: "legacy_orders"
  """
  legacy_orders_aggregate("distinct select on columns" distinct_on: [legacy_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [legacy_orders_order_by!], "filter the rows returned" where: legacy_orders_bool_exp): legacy_orders_aggregate!

  """
  fetch data from the table: "legacy_orders" using primary key columns
  """
  legacy_orders_by_pk(hash: String!): legacy_orders

  """
  fetch data from the table: "marketplace_activity"
  """
  marketplace_activity("distinct select on columns" distinct_on: [marketplace_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_activity_order_by!], "filter the rows returned" where: marketplace_activity_bool_exp): [marketplace_activity!]!

  """
  fetch aggregated fields from the table: "marketplace_activity"
  """
  marketplace_activity_aggregate("distinct select on columns" distinct_on: [marketplace_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_activity_order_by!], "filter the rows returned" where: marketplace_activity_bool_exp): marketplace_activity_aggregate!

  """
  fetch data from the table: "marketplace_activity" using primary key columns
  """
  marketplace_activity_by_pk(id: uuid!): marketplace_activity

  """
  fetch data from the table: "marketplace_order"
  """
  marketplace_order("distinct select on columns" distinct_on: [marketplace_order_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_order_order_by!], "filter the rows returned" where: marketplace_order_bool_exp): [marketplace_order!]!

  """
  fetch aggregated fields from the table: "marketplace_order"
  """
  marketplace_order_aggregate("distinct select on columns" distinct_on: [marketplace_order_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_order_order_by!], "filter the rows returned" where: marketplace_order_bool_exp): marketplace_order_aggregate!

  """
  fetch data from the table: "marketplace_order" using primary key columns
  """
  marketplace_order_by_pk(id: uuid!): marketplace_order
}

type subscription_root {
  """
  fetch data from the table: "dipdup_contract"
  """
  dipdup_contract("distinct select on columns" distinct_on: [dipdup_contract_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_order_by!], "filter the rows returned" where: dipdup_contract_bool_exp): [dipdup_contract!]!

  """
  fetch aggregated fields from the table: "dipdup_contract"
  """
  dipdup_contract_aggregate("distinct select on columns" distinct_on: [dipdup_contract_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_order_by!], "filter the rows returned" where: dipdup_contract_bool_exp): dipdup_contract_aggregate!

  """
  fetch data from the table: "dipdup_contract" using primary key columns
  """
  dipdup_contract_by_pk(name: String!): dipdup_contract

  """
  fetch data from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata("distinct select on columns" distinct_on: [dipdup_contract_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_metadata_order_by!], "filter the rows returned" where: dipdup_contract_metadata_bool_exp): [dipdup_contract_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_contract_metadata"
  """
  dipdup_contract_metadata_aggregate("distinct select on columns" distinct_on: [dipdup_contract_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_contract_metadata_order_by!], "filter the rows returned" where: dipdup_contract_metadata_bool_exp): dipdup_contract_metadata_aggregate!

  """
  fetch data from the table: "dipdup_contract_metadata" using primary key columns
  """
  dipdup_contract_metadata_by_pk(id: Int!): dipdup_contract_metadata

  """
  fetch data from the table: "dipdup_head"
  """
  dipdup_head("distinct select on columns" distinct_on: [dipdup_head_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_order_by!], "filter the rows returned" where: dipdup_head_bool_exp): [dipdup_head!]!

  """
  fetch aggregated fields from the table: "dipdup_head"
  """
  dipdup_head_aggregate("distinct select on columns" distinct_on: [dipdup_head_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_order_by!], "filter the rows returned" where: dipdup_head_bool_exp): dipdup_head_aggregate!

  """
  fetch data from the table: "dipdup_head" using primary key columns
  """
  dipdup_head_by_pk(name: String!): dipdup_head

  """
  fetch data from the table: "dipdup_head_status"
  """
  dipdup_head_status("distinct select on columns" distinct_on: [dipdup_head_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_status_order_by!], "filter the rows returned" where: dipdup_head_status_bool_exp): [dipdup_head_status!]!

  """
  fetch aggregated fields from the table: "dipdup_head_status"
  """
  dipdup_head_status_aggregate("distinct select on columns" distinct_on: [dipdup_head_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_head_status_order_by!], "filter the rows returned" where: dipdup_head_status_bool_exp): dipdup_head_status_aggregate!

  """
  fetch data from the table: "dipdup_index"
  """
  dipdup_index("distinct select on columns" distinct_on: [dipdup_index_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_index_order_by!], "filter the rows returned" where: dipdup_index_bool_exp): [dipdup_index!]!

  """
  fetch aggregated fields from the table: "dipdup_index"
  """
  dipdup_index_aggregate("distinct select on columns" distinct_on: [dipdup_index_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_index_order_by!], "filter the rows returned" where: dipdup_index_bool_exp): dipdup_index_aggregate!

  """
  fetch data from the table: "dipdup_index" using primary key columns
  """
  dipdup_index_by_pk(name: String!): dipdup_index

  """
  fetch data from the table: "dipdup_schema"
  """
  dipdup_schema("distinct select on columns" distinct_on: [dipdup_schema_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_schema_order_by!], "filter the rows returned" where: dipdup_schema_bool_exp): [dipdup_schema!]!

  """
  fetch aggregated fields from the table: "dipdup_schema"
  """
  dipdup_schema_aggregate("distinct select on columns" distinct_on: [dipdup_schema_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_schema_order_by!], "filter the rows returned" where: dipdup_schema_bool_exp): dipdup_schema_aggregate!

  """
  fetch data from the table: "dipdup_schema" using primary key columns
  """
  dipdup_schema_by_pk(name: String!): dipdup_schema

  """
  fetch data from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata("distinct select on columns" distinct_on: [dipdup_token_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_token_metadata_order_by!], "filter the rows returned" where: dipdup_token_metadata_bool_exp): [dipdup_token_metadata!]!

  """
  fetch aggregated fields from the table: "dipdup_token_metadata"
  """
  dipdup_token_metadata_aggregate("distinct select on columns" distinct_on: [dipdup_token_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dipdup_token_metadata_order_by!], "filter the rows returned" where: dipdup_token_metadata_bool_exp): dipdup_token_metadata_aggregate!

  """
  fetch data from the table: "dipdup_token_metadata" using primary key columns
  """
  dipdup_token_metadata_by_pk(id: Int!): dipdup_token_metadata

  """
  fetch data from the table: "indexing_status"
  """
  indexing_status("distinct select on columns" distinct_on: [indexing_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [indexing_status_order_by!], "filter the rows returned" where: indexing_status_bool_exp): [indexing_status!]!

  """
  fetch aggregated fields from the table: "indexing_status"
  """
  indexing_status_aggregate("distinct select on columns" distinct_on: [indexing_status_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [indexing_status_order_by!], "filter the rows returned" where: indexing_status_bool_exp): indexing_status_aggregate!

  """
  fetch data from the table: "indexing_status" using primary key columns
  """
  indexing_status_by_pk("COLLECTION: COLLECTION\\nLEGACY_ORDERS: LEGACY_ORDERS" index: String!): indexing_status

  """
  fetch data from the table: "legacy_orders"
  """
  legacy_orders("distinct select on columns" distinct_on: [legacy_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [legacy_orders_order_by!], "filter the rows returned" where: legacy_orders_bool_exp): [legacy_orders!]!

  """
  fetch aggregated fields from the table: "legacy_orders"
  """
  legacy_orders_aggregate("distinct select on columns" distinct_on: [legacy_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [legacy_orders_order_by!], "filter the rows returned" where: legacy_orders_bool_exp): legacy_orders_aggregate!

  """
  fetch data from the table: "legacy_orders" using primary key columns
  """
  legacy_orders_by_pk(hash: String!): legacy_orders

  """
  fetch data from the table: "marketplace_activity"
  """
  marketplace_activity("distinct select on columns" distinct_on: [marketplace_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_activity_order_by!], "filter the rows returned" where: marketplace_activity_bool_exp): [marketplace_activity!]!

  """
  fetch aggregated fields from the table: "marketplace_activity"
  """
  marketplace_activity_aggregate("distinct select on columns" distinct_on: [marketplace_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_activity_order_by!], "filter the rows returned" where: marketplace_activity_bool_exp): marketplace_activity_aggregate!

  """
  fetch data from the table: "marketplace_activity" using primary key columns
  """
  marketplace_activity_by_pk(id: uuid!): marketplace_activity

  """
  fetch data from the table: "marketplace_order"
  """
  marketplace_order("distinct select on columns" distinct_on: [marketplace_order_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_order_order_by!], "filter the rows returned" where: marketplace_order_bool_exp): [marketplace_order!]!

  """
  fetch aggregated fields from the table: "marketplace_order"
  """
  marketplace_order_aggregate("distinct select on columns" distinct_on: [marketplace_order_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [marketplace_order_order_by!], "filter the rows returned" where: marketplace_order_bool_exp): marketplace_order_aggregate!

  """
  fetch data from the table: "marketplace_order" using primary key columns
  """
  marketplace_order_by_pk(id: uuid!): marketplace_order
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz

  _gt: timestamptz

  _gte: timestamptz

  _in: [timestamptz!]

  _is_null: Boolean

  _lt: timestamptz

  _lte: timestamptz

  _neq: timestamptz

  _nin: [timestamptz!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid

  _gt: uuid

  _gte: uuid

  _in: [uuid!]

  _is_null: Boolean

  _lt: uuid

  _lte: uuid

  _neq: uuid

  _nin: [uuid!]
}

schema {
  query: query_root
  subscription: subscription_root
}
